# Programmers

## 코딩테스트 연습

### 해시

#### 완주하지 못한 선수

- 배운점 및 풀이과정:

  - 정확성 뿐만 아니라 효율성에 대해서도 생각해볼 수 있었던 문제
  - 해시 구조에 대해서 간략하게나마 이해할 수 있었다.
  - 해시 구조가 key값에 value를 저장하는 형태라 파이썬의 딕셔너리가 해시 테이블의 예다.
  - key에서 value를 바로 가져올 수 있어서 속도가 빨라진다(라고 한다).
  - 왜 이렇게 하면 빨라지는지에 대해서는 추가적으로 공부가 필요하다.

  

  - 정답은 맞으나 효율성에서 시간 초과가 계속 되풀이 되었다.
  - 딕셔너리를 제대로 사용하면 속도를 많이 개선할 수 있다는 것을 배웠다.
  - 처음에 풀이를 할 때는 딕셔너리를 적극적으로 활용하지 못했다. participant 배열의 요소 중에 completion에 들어있지 않은게 있다면 그걸 return 하거나, 만약에 없다면 그때 딕셔너리로 participant 배열의 요소별 숫자를 세서 2 이상의 값인 요소를 return 하려고 했다.
  - 이 방법으로는 통과를 하지 못해서 이후 풀이에서는 처음부터 completion 배열의 요소별 개수를 딕셔너리에 저장했다. 그리고 participant 배열 요소별로 딕셔너리 key 값과 일치하는게 없다면 return 하거나, 일치하면 value를 1씩 감소시키고 음수가 되는 key 값을 return하려고 했다.
  - 이 방법도 답은 맞췄지만 효율성 검사에서 시간 초과가 났다. 아마 딕셔너리를 만드는 방식에서 효율이 떨어졌던 것 같다.
  - 그래서 딕셔너리에 대해서 찾아보다가 코딩 도장의 fromkeys 메소드를 알게 됐다. 

  ```python
  arr = [1, 2, 3, 4, 5]
  a = dict.fromkeys(arr)
  # arr의 요소들을 a의 key 값으로 저장하고 value는 None으로 된다.
  
  a = dict.fromkeys(arr, 10)
  # arr의 요소들을 a의 key 값으로 저장하는 것은 위와 동일하나 여기서는 10을 지정해주면서 10은 value 값으로 저장되는 점이 다르다.
  ```

  - fromkeys 메소드를 활용해서 효율성도 통과했다.
  - formkeys 메소드가 좋은 점은 아래의 상황을 해결해줄 수 있다.

  ```python
  dic = dict()
  arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]
  for i in arr:
      dic[i] = arr.count(i)
  # 이렇게 하면 오류가 난다. 왜냐하면 빈 딕셔너리에 key 자체가 없기 때문에 key에 value를 할당할 수가 없다. 처음에 왜 이게 안되는지 바로 알지 못해서 헤맸다.
  # fromkeys 메소드로 key와 value를 할당한 후에 진행하면서 해결했다.
  ```

  


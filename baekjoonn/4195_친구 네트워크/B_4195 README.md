# 백준

## 4195

disjoin-set을 활용하는 문제다.

정수가 아닌 문자열로 주어져서 더 까다로운 문제였다.

그래서 문자열로 주어진 이름을 정수화하기 위해 딕셔너리를 통해 인덱스를 부여했다. 이 인덱스로 make_set, find_set, union 연산을 수행한다.

그리고 값은 친구의 숫자를 나타내야해서 height(or rank)가 아닌 size를 기준으로 풀이했다. find_set 연산은 path compression을 통해서 최상위 부모 요소를 나타내도록 했고, 이를 바탕으로 최상위 부모 요소가 서로 다르면 왼쪽 요소에 오른쪽 요소의 size를 더해줬다.

주의해야할 점은 ~~(내가 헷갈렸다)~~ 최상위 부모 요소가 서로 다를때 더해준다는 점이다. 즉 친구 두 명을 비교하는데 이들의 부모 요소가 서로 같으면 이미 동일한 그룹에 속해있다는 뜻이다. 입력으로 받는 두 명의 친구만을 생각하면 된다. 두 명의 최상위 부모 요소가 달라야 합쳐줄 수 있다.

예를 들어,

```
Fred Barney
```

Fred와 Barney가 처음 입력으로 주어졌다고 하면, 이들은 최상위 부모 요소가 본인 자신이라 서로 다르다. 이때 왼쪽에 있는 Fred에 Barney를 포함시킨다고 하자.

```
Barney Betty
```

다음 입력으로 Barney와 Betty가 주어지면 Barney의 최상위 부모 요소는 Fred이고 Betty는 본인 자신이다. 최상위 부모 요소가 서로 다르다. 왼쪽에 있는 Barney의 최상위 부모 요소인 Fred에 Betty를 포함시켜준다.

또 하나 주의할 점은 size는 0이 아닌 1부터 해야한다는 점이다.

그간 union by height를 다뤄봤으나 union by size는 처음이라 낯설게 느껴졌다.

<br>

문자열을 정수로 인덱스화하는 것과 union by size 두가지가 문제 풀이의 가장 중요한 요소라고 생각한다.


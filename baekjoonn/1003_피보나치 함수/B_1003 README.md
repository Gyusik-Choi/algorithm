# 백준

## 1003

피보나치 수 자체를 구하는게 아니라 0과 1이 호출된 횟수를 세는 문제였다.

문제에서 재귀적으로 피보나치 수를 구하는 C++ 코드 자체를 보여주면서 문제를 설명한게 독특했다.

메모이제이션을 통해서 문제를 해결하면 3 이상의 숫자는 모두 0은 1번, 1은 2번 호출된다. 왜냐면 3을 구할 때 2의 값을 구하는 것과 1을 구하는 것을 호출한다. 2를 구할 때 1과 0이 호출되고 1은 1자신을 호출하게 된다. 그래서 3 이상의 숫자는 0은 1번 1은 2번으로 동일한 횟수로 호출하게 된다.

위의 경우는 개별적으로 구했을 경우고 만약 문제처럼 입력 값이 여러개 주어지면 해당 입력 값의 숫자를 구할 때 마다 메모이제이션에 구하게된 숫자가 쌓인다. 그래서 0과 1의 호출 횟수는 더 적어질 수 있다.

메모이제이션이 아니라 재귀적으로 직접 구해보니 규칙을 발견할 수 있었다.

```
입력값 => 0호출 1호출
3 => 1 2
4 => 2 3
5 => 3 5
6 => 5 8
```

0과 1의 호출 횟수 자체가 피보나치 적으로 증가하는 규칙을 보인다.

입력 값 3의 경우는 각각 2와 3의 피보나치 값, 4는 각각 3과 4의 피보나치 값 이렇게 점진적으로 증가한다. 즉, 입력 값 보다 1 작은 수의 피보나치 값과 입력 값과 동일한 수의 피보나치 값이 0과 1의 호출횟수가 된다.

그래서 최대 입력 값인 40을 메모이제이션으로 구한 뒤에 입력 값의 1보다 작은 수의 value와 입력 값의 value를 메모이제이션에서 구한 뒤 출력했다. 




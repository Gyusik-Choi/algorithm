# 백준

## 14501

이것이 코딩테스트다 교재에 수록된 문제로서 다이나믹 프로그래밍 유형의 문제다.

그간 다이나믹 프로그래밍 유형을 풀이할때 대부분의 경우에 현 인덱스 값을 앞선 인덱스 값과 연계해서 구하고 다음 인덱스의 값을 앞선 인덱스의 값과 연계해서 풀이해 나가면서 답을 구하려 했다. 이때 앞선 인덱스가 바로 현 인덱스에서 1만큼 앞에 있는 경우가 많았다. 그래서 이럴 경우에 현 인덱스를 기준으로 앞선 인덱스를 구하는데 어려움이 없었다. 그냥 바로 앞의 인덱스와 비교하면 됐기 때문이다.

이 문제는 현 인덱스를 기준으로 비교할 앞선 인덱스를 구하는데 어려움을 겪었다. 현 인덱스에서 앞선 인덱스가 아닌 이후의 인덱스에 대한 정보들을 상담 일정으로 갖고 있어서 현 인덱스와 비교할 앞선 인덱스를 어떻게 알아내야 할지가 어려웠다.

이 문제에서 비교할 앞선 인덱스를 완전탐색 방식으로 구했다. 현재 인덱스 보다 앞에 있는 모든 요소들을 검사해서 현재 인덱스 - 앞선 인덱스 값이 앞선 인덱스의 상담 일정 보다 크거나 같은 경우에만 dp 배열의 값을 비교한다.

점화식으로 나타내면 아래와 같다.

```
dp[현재 인덱스] = max(dp[현재 인덱스], dp[앞선 인덱스] + schedule[현재인덱스][1])
```

<br>

이때 주의할점은 앞선 인덱스 dp 값이 필요하기 때문에 일단 초기 dp 값으로 해당 인덱스의 금액을 설정해준다. 설령 완료할 수 없는 경우(문제에서 주어진 예시의 6일, 7일이 각각 4일, 2일 동안 상담이 필요해서 퇴사하는 8일 이전까지 상담을 완료할 수 없음)라도 우선 값을 대입해주고 추후에 dp 값을 계산한 이후에 조건에 안 맞는 값(퇴사 이전에 상담 완료 못함)이면 최대값을 구하는 것에서 제외한다.

<br>

<참고>

https://mygumi.tistory.com/151


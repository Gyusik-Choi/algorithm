# 백준

## 2750

문제 안내에 '시간 복잡도가 O(n²)인 정렬 알고리즘으로 풀 수 있습니다. 예를 들면 삽입 정렬, 거품 정렬 등이 있습니다.' 라고 되어있다.

삽입 정렬, 거품 정렬과 마찬가지로 시간 복잡도 O(n²)인 선택 정렬을 활용해서 풀이했다. 이중 for문을 돌게 되므로 시간 복잡도는 배열 길이가 n이라고 하면 n X n 만큼 비교가 일어나서 n제곱만큼의 시간 복잡도를 갖는다.

오름차순으로 정렬할 때, 거품 정렬은 매번 비교 할때마다 앞의 요소가 뒤의 요소보다 크면 교환해야 한다. 그러나 선택정렬은 바깥 for문의 아이템이 안쪽 for문을 다 돌고나서 한번만 교환하게 된다.

문제의 예제 입력으로 교환 횟수를 비교하면

```python
# 선택 정렬
def selection_sort(lst):
    global s_cnt
    for j in range(len(lst) - 1):
        min_idx = j
        for k in range(j + 1, len(lst)):
            if lst[min_idx] > lst[k]:
                min_idx = k
        lst[j], lst[min_idx] = lst[min_idx], lst[j]
        s_cnt += 1
    return lst


N = int(input())
arr = []
for i in range(N):
    num = int(input())
    arr.append(num)

s_cnt = 0
s_ans = selection_sort(arr)
print(s_cnt)
# 출력: 4
```

```python
# 거품 정렬
def bubble_sort(lst):
    global b_cnt
    for j in range(len(lst) - 1, -1, -1):
        for k in range(j):
            if lst[k] > lst[k + 1]:
                lst[k], lst[k + 1] = lst[k + 1], lst[k]
                b_cnt += 1
    return lst


N = int(input())
arr = []
for i in range(N):
    num = int(input())
    arr.append(num)

b_cnt = 0
b_ans = bubble_sort(arr)
print(b_cnt)
# 출력: 7
```

예제 입력은 숫자가 5, 2, 3, 4, 1 이렇게 총 5개다. 선택 정렬은 교환 횟수가 4번이고 거품 정렬은 7번이다. 입력 받는 숫자가 커지면 (물론 입력 받는 숫자에 따라 달라질 수 있지만) 그 차이는 더욱 커질 확률이 높다.



자바로 풀이를 하면서 파이썬 풀이에서 선택한 선택 정렬이 아니라 삽입 정렬을 활용했다. 삽입 정렬은 거품 정렬이나 선택 정렬과 달리 정렬의 범위가 점점 늘어난다. 처음에는 맨 처음의 두 원소를 비교하고, 그 다음에는 맨 처음부터 세번째 원소까지 비교하고 이렇게 점점 범위를 늘려나간다. 비교할때 앞에서 뒤의 원소를 비교하는게 아니라 뒤에서부터 앞의 원소를 비교해나간다. 

배열 [5, 4, 3, 2, 1] 이 있다고 하면 맨 처음 두개를 비교할때 4보다 5가 더 크므로 둘의 위치를 바꾼다. 배열은 [4, 5, 3, 2, 1] 이 된다. 그 다음은 맨 처음부터 3번째까지의 원소를 비교한다. 앞에서 뒤에서 앞으로 비교해나간다고 했으므로 3부터 5와 비교한다. 5가 더 크므로 3과 5를 바꾼다. 배열은 [4, 3, 5, 2, 1] 이렇게 된다. 그리고 두번째와 첫번째 원소인 3과 4를 비교한다. 4가 더 크므로 3과 4의 위치를 바꾼다. 배열은 [3, 4, 5, 2, 1] 이렇게 된다. 배열이 이렇게 된 경우에는 처음부터 계속해서 맨 앞까지 쭉 비교를 해나가야 하지만 이것과 다른 경우에는 맨 앞까지 비교를 하지 않아도 된다.

배열 [3, 1, 2, 5, 4] 이렇게 있다고 하면 맨 앞의 두개인 3과 1을 비교하면 3이 더 크므로 3과 1의 위치를 바꾼다. 배열은 [1, 3, 2, 5, 4] 이 된다. 그리고 앞의 세개를 비교한다. 세번째와 두번째를 비교하고, 두번째를 비교하고 첫번째를 비교하면 된다. 세번째와 두번째를 비교하면 배열은 [1, 2, 3, 5, 4]가 된다. 그리고 두번째와 첫번째를 비교하는데 1이 작으므로 위치를 바꿀 필요가 없다. 그 다음은 앞의 4개를 비교하는데 5의 경우는 비교를 3번이나 할 필요가 있을까? 그렇지 않다. 3과 비교해보고 이미 5가 더 크므로 추가적으로 비교할 필요가 없다. 왜냐면 이미 앞 부분은 정렬이 완료되었다. 5의 경우에 3이 자신보다 작기 때문에 3보다 앞에 있는 숫자는 3보다 작거나 같음이 보장되므로 더 비교할 필요가 없다.



참고

https://www.daleseo.com/sort-insertion/
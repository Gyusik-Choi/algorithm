# SWEA

## 2814 최장경로

### 알고리즘

- DFS 재귀



### 어려웠던 점

```
여러 시행착오가 있었다. BFS로 처음에 시도를 했다. 1 2, 1 3, 2 6, 3 4, 4 5 이런 경우에 1에서 5를 간다고 하면 같은 레벨의 노드들을 queue에 담은 후에 그 상위 노드는 visited에 담은 후 1을 더해주면 1에서 1, 2와 3에서 2, 6과 4에서 3, 그리고 1과 5에서 4가 되어서 정답을 찾을 수 있다고 생각했다.
지금 정리하는 와중에 다시 보면서 굳이 BFS를 처음에 했어야 했나 싶다. DFS로 애초에 했어야 했다는 생각이 든다. 다만 DFS를 백트래킹 등 스택으로 풀기 어려운 경우를 제외하면 재귀 보다 스택으로 푸는 것을 선호하다 보니 여기서는 DFS 스택은 처음에 1에서 스택에 2와 3을 넣어버리니 재귀가 아닌 이상에 2와 3 둘 중에 하나만 선택할 수가 없었다.
그래서 재귀로 하기 싫어서 BFS로 생각해보니 답을 찾을 수 있을 것 같아서 BFS를 하면서 끊임없는 삽질의 연속이었다. 계속 10개의 테스트케이스 중 5개만 맞았다.
뭔가 잘못됐다는 생각이 들었고 DFS의 재귀로 가게 됐다. 여기서도 쉽지 않았다. 잘 안하다보니 역시 코드를 짜는거부터 쉽지 않았다. 연습 부족이 원인이다. 그렇지만 재귀는 재귀가 돌기 전에 방문 처리를 하고 아래에 방문 처리를 취소하는 코드를 배치하면서 반복이거나 찾아야할 노드가 없어서 return None이 되는 경우에 방문을 알아서 취소해줬다.
그래서 계속 발목을 잡았던, 디버깅을 위해 사용했던 1 2, 1 3, 2 3, 2 4, 2 6, 3 4, 4 5에서 1에서 5를 갈때 기존의 BFS는 6을 계속 포함할 수 밖에 없었으나 재귀를 통해 6을 가게 되면 2가 이미 visited에 있기에 return None이 되고 6의 방문을 취소할 수 있었다.
```


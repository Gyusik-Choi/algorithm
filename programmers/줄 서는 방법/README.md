# 프로그래머스

## 줄 서는 방법

n 명의 사람을 줄 세우는 방법은 n! 개다.

k 의 최대 크기가 20! 이 될 수 있어서 재귀적으로 순열을 구하면 시간 초과가 발생한다.

n 명의 사람 중 첫번째 자리에 올 수 있는 사람은 n 명이고 각자 (n - 1)! 개의 경우의 수를 갖는다. 즉 k 에서 (n - 1) ! 을 나눈 몫으로 첫번째 자리에 올 사람을 구할 수 있다.

예를 들어, n 이 5, k 가 34라고 하면 (n - 1)! 은 24다. 34에서 24를 나눈 몫은 1인데 인덱스는 0부터라 2가 첫번째 자리에 온다. k! 은 120 이다. 1부터 5는 각각 24개의 경우의 수를 갖기 때문에 34번째 경우의 수는 첫번째 자리 값이 2가 된다.

첫번째 자리를 구한 후 두번째 자리를 이어서 구하기 위해 k 는 (n - 1)! 로 나눈 나머지로 대체하고, n 은 1을 빼준다. k 는 10이 된다. 첫번째 자리 수를 기준으로 10번째(34 % 24 = 10)에 있는 경우의 수를 찾아야 한다. 

<br>

### 의문점

풀이 1과 풀이 2는 k가 변화하는 양상이 다른데 어떻게 동일한 답이 나올 수 있을까?

풀이 1은 k를 idx 를 구할 때는 1을 뺀 값에서 구하고 k를 갱신할 때는 1을 빼지 않고 원래 k 값으로 구한다.

풀이 2는 while 문에 들어가기 전에 k에서 1을 뺀다. 그리고는 idx 를 구하고 k 를 갱신할 때 모두 k 에서 1을 빼지 않는다.

풀이 1과 풀이 2는 while 문의 첫번째 순회에서 idx 를 구할 때만 k가 같고 그 외는 k 값이 기본적으로 다르다. 의문점은 k 가 다른데 어떻게 값이 풀이1과 풀이2가 같을 수 있는지였다.

while 문의 첫번째 순회에서 idx 를 구할 때를 제외하면 보통의 경우 풀이 1의 k 가 풀이 2의 k 보다 1이 크다. 1 차이라 idx 를 구하거나 k 를 갱신할 때 값에 크게 영향을 주지 않기도 하지만 영향을 주는 경우가 2가지 있다. 

<br>

#### 경우 1 - 풀이 1에서 k 를 갱신할 때 0이 될 경우

풀이 1의 k 를 갱신해서 0이 된다면 풀이 1의 k 는 0, 풀이 2의 k 는 앞서 k 를 갱신할 때 나눴던 factorial - 1이 된다. 예를 들어 factorial 이 24, 풀이 1의 k 가 48, 풀이 2의 k 가 47 이었다면 풀이 1의 k 는 0이 되고, 풀이 2의 k 는 24 - 1인 23이 된다.

풀이 1의 k 가 0이 되면 idx 는 -1이 된다. 파이썬에서 -1을 리스트 인덱스로 접근하면 맨 마지막 값을 조회한다. k 를 나머지 연산으로 갱신하는 이유는 해당 자리수를 찾고 나머지 자리 수를 찾을 때 나올 수 있는 경우의 수 중에서 몇 번째 경우의 수에 있는지 찾기 위해서다. 갱신된 k 가 factorial - 1 이 됐다는 것은 맨 마지막 경우의 수라는 것이다. idx 를 구하면 가장 마지막 인덱스가 나온다.

<br>

#### 경우 2- 풀이 2에서 k 를 갱신할 때 0이 될 경우 

풀이 2의 k 를 나머지 연산으로 갱신하면서 0이 됐다면 풀이 1의 k 는 1이다. idx 를 구하면 둘 다 0이 된다. 풀이 1에서 idx 를 구하는 코드는 (k - 1) // factorial 이고, 풀이 2에서 idx 를 구하는 코드는 k // factorial 이다. 풀이 1에서 k 가 1이면 idx 를 구할 때 1에서 1을 빼면 0이 되고 이를 factorial 로 나눈 몫은 0이다. 풀이 1에서 n 이 3 이상일 때 k 가 0이 됐다면 n 이 2가 되야 k 가 0으로 갱신될 수 있고 n 이 2보다 클 때는 계속 k 는 0이다.  n 이 2면 factorial 이 1이 되고 1(k)과 1(factorial)을 나머지 연산하면 0이 돼서 k 가 0으로 갱신된다.

k 가 0이라면 n 이 2가 될 때까지 idx 는 풀이 1, 풀이 2 둘 다 0이 나온다. n 이 2일 때 풀이 1의 k 는 0으로 갱신되면서 n 이 1이면 풀이 1에서 idx 는 -1이 된다((k - 1) / factorial 인데 k 가 0이라 -1이 되고 factorial 로 나눠도 몫은 -1 이다). n 이 1이라는 것은 리스트에 요소가 하나 밖에 없다는 의미다. idx 가 -1 이면 idx 가 0 인 것과 같은 요소에 접근한다.

<br>

정리하자면, k가 0이 되려면 k 가 factorial 로 나눠 떨어져야 한다. 나눠 떨어지는 경우가 풀이 1과 풀이 2가 다르기 때문에 같은 idx 값을 갖게 된다.

풀이 1에서 k 가 나눠 떨어지면 idx 는 -1이 된다. 이때 풀이 2에서 k 는 k 가 풀이 1의 k 보다 1이 작기 때문에 나눠 떨어지지 않고 factorial - 1 이 돼서 idx 를 구하면 리스트의 맨 마지막 인덱스가 된다. 파이썬에서 인덱스 -1은 리스트의 맨 마지막 인덱스를 가리키므로 맨 마지막 인덱스와 사실상 같은 의미를 갖는다.

풀이 2에서 k 가 나눠 떨어지면 k 가 0이 되고 idx 도 0이 된다. 이때 풀이 1에서 k 는 k 가 풀이 2의 k 보다 1이 크기 때문에 idx 를 구하는 코드의 일부인 k - 1 에 의해 1에서 1을 빼서 0이 되고 idx 는 0이 나온다. 풀이 2에서 k 가 0 이돼서 idx 가 0이 되면 풀이 1의 idx 도 0이 돼서 둘 다 리스트의 첫번째 인덱스를 조회한다.

<br>

<참고>

https://hstory0208.tistory.com/entry/Python%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-Lv2-%EC%A4%84-%EC%84%9C%EB%8A%94-%EB%B0%A9%EB%B2%95

https://kangworld.tistory.com/258






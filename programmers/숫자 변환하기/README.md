# 프로그래머스

## 숫자 변환하기

BFS 혹은 DP 를 활용해서 풀이할 수 있는 문제다.

DFS, BFS 중에 어떤 알고리즘을 활용해야 할지 판단하는 기준을 잘 세워야 한다는 것을 느낄 수 있는 문제였다.

<br>

### BFS 풀이

이번 문제는 경우의 수가 몇 개인지 판단하는게 아니라 최소 횟수 하나를 구하는 문제다. DFS 가 아닌 BFS 를 활용해야 한다.

시작점인 x 값을 덱에 넣고 덱이 빌 때까지 while 문을 돌면서 3가지 연산 결과에 대한 값이 y 보다 작고 중복 연산을 막기 위해 이전에 연산된 값이 아닌 경우 덱에 추가해서 연산을 이어간다. BFS 탐색이므로 x 와 y 가 같은 경우가 나오면 이 경우가 바로 최소 횟수라 현재까지의 연산 횟수를 리턴한다.

<br>

### DP 풀이

DP 풀이는 두 가지 방법으로 진행했다.

첫번째 방법은 과거 값을 통해 현재 값을 계산했다면, 두번째 방법은 현재 값을 통해 미래 값을 계산했다.

프로그래머스에 제출했을 때 시간은 두번째 방법이 모든 케이스는 아니었지만 대체로 5~10배 가량 빨랐다.

<br>

#### 첫번째 방법

dp 리스트를 y + 1 크기만큼 생성하고 float('inf') 로 초기화 하고 x 인덱스를 0으로 설정한다.

x + 1 부터 y까지 for 문을 돌면서 해당 요소의 위치 값을 이전에 구한 값과 비교한다. 해당 인덱스 값은 추후 인덱스에서 참조될 수 있다.

n 을 더하거나, 2를 곱하거나, 3을 곱해서 해당 요소의 값이 나올텐데 이전의 최소 횟수 값에서 1을 더하게 된다. 해당 요소의 값이 i 라면 i - n 인덱스, i // 2 인덱스, i // 3 인덱스와 현재 i 의 값 중 최소값을 선택하는 방식이다.

연산을 줄이기 위해 i // 2, i // 3 인덱스는 각각 2, 3 으로 나누어 떨어질 경우만 최소값을 찾는다.

<br>

#### 두번째 방법

dp 리스트를 y + 1 크기만큼 생성하고 float('inf') 로 초기화 하고 x 인덱스를 0으로 설정한다.

첫번째 방법과 달리 x 부터 y 까지 for 문을 돈다. for 문의 요소에서 n 을 더한 인덱스, 2를 곱한 인덱스, 3을 곱한 인덱스의 값을 기존 값과 비교해서 더 작은 값으로 변경한다.

y 이상의 값은 비교할 필요가 없기 때문에 비교하기 전에 n을 더한 인덱스, 2를 곱한 인덱스, 3을 곱한 인덱스가 각각 y 보다 작거나 같은 경우에만 비교를 한다.

<br>

<참고>

https://www.acmicpc.net/problem/1697

https://chanhuiseok.github.io/posts/baek-14/

https://great-park.tistory.com/19

https://velog.io/@lifeisbeautiful/%EB%B0%B1%EC%A4%80-1697%EB%B2%88-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88-DP-Java-Kotlin

https://studyposting.tistory.com/93


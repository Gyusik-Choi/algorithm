# 프로그래머스

## 입국심사

### Java

#### Programmers43238

어려운 문제였다. 교재의 풀이를 참고했다.

문제를 읽었을 때는 먼저 우선순위 큐를 사용하는 방법이 떠올랐으나 사용하기 어려울 것이라는 생각이 들었다. n 이 최대 10억이나 되고 프로그래머스에서 해당 문제가 '이분탐색' 카테고리에 포함되기 때문이다. '자바 알고리즘 인터뷰' 교재에도 이 문제는 '이진탐색' 카테고리에 포함된다.

다만 어떻게 이진탐색을 적용할 수 있을지 해결 방법이 잘 떠오르지 않았다. 교재는 시간을 기준으로 중간값을 정한다. 중간값을 구하려면 최소 시간과 최대 시간이 있어야 한다. 

최소 시간은 n의 최소값이 1이고 심사관이 한 명을 심사하는데 걸리는 최소 시간이 1분이라 1명과 1분을 곱해서 1로 할 수 있다. 최대 시간은 최적화가 필요하다. 무조건 10억명과 10억분을 곱해서 구하게 되면 너무나 많은 이진 탐색을 해야해서 이렇게 접근하면 안 된다. 최대 시간은 times 의 최대값에서 n 을 곱한 값으로 구한다. 모든 사람들이 다른 줄에 서지 않고 시간이 가장 오래 걸리는 심사관에게 심사를 받았을 때 나올 수 있는 최대 시간이다.

이 문제에서 유의할 점은 최소 시간과 최대 시간을 바탕으로 중간 값을 구할 수 있게 됐으나 직접적으로 중간 값과 어떤 값을 비교해서 left 와 right 를 조정하지 않는다. 탐색 범위를 결정하는 조건은 n 과 중간 값에 times 의 각 인원을 나눈 총합이다. 

times 는 각 심사관들이 한 명을 심사하는 걸리는 시간을 나타내는 배열이다. 중간 값으로 나온 시간에서 times 의 각 요소들을 나누면 심사관마다 해당 시간 안에 몇 명을 심사했는지 알 수 있고 이 인원의 합이 시간 안에 심사한 총 인원이 된다. 총 인원이 n 보다 작으면 심사를 다 끝내지 못했기 때문에 left 를 올려야 하고, 총 인원이 n 보다 크거나 같으면 심사를 다 끝냈다는 의미고 보다 작은 시간내에 심사를 마칠 수도 있기 때문에 right 를 줄인다.

이진 탐색은 교재와 다르게 구현했다. python 의 bisect 모듈에 있는 bisect_left 함수와 유사하게 구현했다. 별도로 리턴할 변수를 두지 않고 left 를 리턴한다. 리턴할 left 를 구하기 위해 left 와 right 범위를 조정하는데 유의해야 한다. mid 값은 왼쪽으로 편향된 중간 값이 나오기 때문에 left 는 mid + 1, right 는 mid 로 조정한다.

여기서 왼쪽으로 편향된 중간 값이라는 뜻은 인접(left 와 right 의 차이가 1인 경우)한 left 와 right 를 더해서 2로 나누면 left 값이 나온다는 의미다. 예를 들어 left 가 0, right 가 1일 때 left 와 right 를 더해서 2로 나누면 0이 된다. left 가 1, right 가 2인 경우는 동일한 연산을 하면 1이 나온다. 이렇게 왼쪽에 치우친 중간 값이 나올 수 있어서 left 는 mid + 1, right 는 mid 로 조정한다.

<br>

```sql
[1, 2, 3, 4, 5]
```

right 도 mid - 1 로 해도 되지 않을까 하는 생각이 들 수 있는데 위와 같은 배열에서 이진 탐색으로 2를 찾는다고 할 때 right 를 mid - 1 로 조정하면 정답을 찾을 수 없다.

left 는 0, right 는 4에서 시작해서 mid 는 2가 된다. 2번 인덱스의 값은 3이라 2보다 크다. 여기서 right 를 mid - 1 로 하면 right 는 1이 된다. left 와 right 는 인접(left 와 right 의 차이가 1)하게 됐고 왼쪽에 편향된 mid 가 구해져서 mid 는 0이 되면서 2를 찾을 수 없게 된다. 

<br>

#### Programmers43238_2

교재의 풀이를 참고했다.

마찬가지로 교재를 참고한 Programmers43238 와 동일한 방식으로 풀이했다. 이진 탐색의 범위로 사용되는 변수 중 하나인 high 를 초기화할 때 long 으로 캐스팅하는데 주의해야 한다. long 으로 캐스팅하지 않고 int 로 사용하면 오버플로우가 발생할 수 있다.

<br>

### Kotlin

#### Programmers43238

교재의 풀이를 참고했다.

오버플로우에 주의해야 한다. right 를 구할 때 times 의 최대값에서 n 을 곱한 후에 Long 타입으로 변환하면 안 된다. 곱셈에서 오버플로우가 발생할 수 있어서 최대값을 구하면 Long 타입으로 변환한뒤 n 을 곱해야 한다.

<br>

<참고>

자바 알고리즘 인터뷰

https://github.com/python/cpython/blob/3.13/Lib/bisect.py

https://leetcode.com/problems/search-in-rotated-sorted-array/


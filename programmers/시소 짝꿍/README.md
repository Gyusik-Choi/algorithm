# 프로그래머스

## 시소 짝꿍

어려운 문제였다.

<br>

### 잘못된 접근

처음에는 키가 정수, 값이 리스트인 딕셔너리에 weights 를 set 에 넣어서 중복 값을 제거한 후 요소별로 2, 3, 4를 곱한 값을 키, 요소의 인덱스를 값에 넣으려고 했다. 이럴 경우 중복되는 값이 있는 경우를 제대로 처리하기가 어려웠다.

예를 들어 weights 가 [100, 100, 150, 150] 일 경우 100과 150을 각각 3과 2로 곱하면 300이 돼서 시소 짝꿍이 된다. weights 를 set 연산하면 [100, 150] 만 남아서 시소 짝꿍의 쌍이 1개 밖에 나오지 않는다. 이에 대해서는 중복되는 숫자의 갯수를 세서 더해주면 된다고 생각했지만 이는 다른 숫자간의 매칭에서는 해당하지 않고 같은 무게로 매칭할 경우만 해당한다. 

즉, 100과 100 을 매칭(1:1 매칭)할 경우는 중복되는 숫자를 세는 방식으로 해결할 수 있지만 100과 150을 매칭하는 경우는 해결할 수 없다. 엄밀히 말하면 중복되는 숫자를 세기만 해서도 안 된다. weights 가 [100, 100, 100, 100, 150, 150] 인 경우 100 으로 만들 수 있는 쌍은 6개다. 100이 3개가 중복된다고 3을 더하는 것은 안된다. 조합을 구하는 공식인 nC2 로 구해야 한다.

이제 위의 "중복되는 값이 있는 경우를 제대로 처리하기가 어려웠다"는 부분으로 돌아오겠다. weights 가 [100, 100, 150, 150] 인 경우 weights 를 set 에 넣어서 {100, 150} 으로 만든 후 2, 3, 4 를 곱해서 딕셔너리를 구성하면 {200: [0], 300: [0, 1], 400: [0], 450: [1], 600: [1]} 가 된다. 300 의 값으로 1개의 쌍을 만들 수 있다. 여기서 문제가 되는건 실제로는 쌍이 이것보다 더 많다는 점이다. weights 의 인덱스로 쌍을 나타내면 (0, 2), (0, 3), (1, 2), (1, 3) 4개가 된다. 실제 쌍은 4개인데 1개 밖에 찾을 수가 없다.

그렇다고 set 연산을 안하면 1:1 매칭하는 경우를 중복해서 찾게 된다. 예를 들어 weights 가 [100, 100] 인 경우 {200: [0, 1], 300: [0, 1], 400: [0, 1]} 이 되고 200, 300, 400 키에 들은 값의 쌍은 모두 동일한 쌍이라 1개로 구해야 한다. 

<br>

### 풀이

weights 의 요소에서 2, 3, 4 를 곱한 값을 딕셔너리에 넣지 않고 weights 의 요소 자체를 딕셔너리에 넣는다. 이를 통해 하나의 값에 여러 요소가 나오지 않는다. 100과 150이 300에 모두 포함되는 경우가 없다. 100과 150이 300에 들어가면 300에 대한 쌍을 구할 때 weights 에서 100과 150의 갯수를 반영해야 하는데 잘못된 접근에서 소개한 풀이는 set 에 넣은 후 딕셔너리에 넣으면서 이를 구하기 어려웠다. 중복 요소가 제거돼서 조합을 구하는 공식인 nC2 로 1:1 외의 쌍을 구할 수 없었다.

이 풀이는 weights 를 Counter 모듈을 통해 각 요소별 갯수를 딕셔너리로 구한다. 그리고 딕셔너리를 순회하면서 쌍의 총합을 구한다. 쌍으로 나타날 수 있는 무게 비율은 1:1, 2:3, 2:4, 3:4 로 총 4개다.

1:1 쌍의 갯수는 nC2 로 구할 수 있고 그 외의 비율은 각 요소의 갯수를 곱한 값이 된다. 그 외의 비율에서는 nC2 를 하지 않고 각 요소 갯수를 곱하는 이유는 아래에서 설명한다.

딕셔너리를 순회하면서 요소의 갯수가 2개 이상이면 1:1 쌍을 구하기 위해 nC2 로 갯수를 구한다. 만약에 요소 A 와 2:3 비율을 갖는 요소 B가 딕셔너리에 있다면 A 의 갯수와 B 의 갯수를 곱한다.

여기서 2로 나누지 않는 이유는 반대 비율을 구하지 않아서 2로 나눈 것과 사실상 같은 값을 구하게 되어서다. A 에서 2:3 을 비율을 갖는 요소 B 의 경우 B 를 기준으로 A 를 보면 3:2 비율이다. B 요소를 검사할 때도 3:2 가 아닌 2:3 을 구하므로 A 는 이때 구해지지 않는다.

2:4, 3:4 는 2:3 과 같은 방식으로 구할 수 있다. 

<br>

코드에 주석으로 남겨 놓았으나 여기서 다시 언급을 하자면 1:1 매칭 외의 비율을 구할 때는 // 가 아닌 / 연산에 주의해야 한다. 

예를 들어, 무게 270 의 경우 270 * 3 / 4 는 202.5 고 270 * 3 // 4 는 202 다. 202 가 weights 에 존재 했다면 cnt 에 추가가 됐을 것이다. 딕셔너리는 정수.0 (ex> 1.0, 27.0) 으로 접근할 경우딕셔너리에 해당 정수.0 의 키가 존재하지 않는다면 암시적으로 뒤의 .0 은 제거가 되는 것 같다. dic = {1: 2} 를 dic[1.0] 으로 조회하면 2가 나온다. dic = {1: 2, 1.0, 3} 을 dic[1.0] 으로 조회하면 3이 나온다.

<br>

<참고>

https://school.programmers.co.kr/questions/43248

https://velog.io/@sunkyuj/python%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%9C%EC%86%8C-%EC%A7%9D%EA%BF%8D


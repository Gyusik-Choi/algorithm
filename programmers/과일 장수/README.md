# 프로그래머스

## 과일장수

그리디 방식으로 풀이했다. 

상자에 사과 갯수는 딱 맞춰서 들어가야 한다. 상자에 사과를 못 채우면 그 상자는 버려야 한다.

역순으로 score 를 정렬한 후에 m 간격으로 반복문을 돌면서 m 개씩 슬라이싱 했다. 슬라이싱한 배열의 마지막 원소가 점수가 가장 낮으므로 마지막 원소에서 m 을 곱한 값을 profit 변수에 더해줬다.

단, 슬라이싱할 길이가 m 이 되지 않으면 slicing 하지 않고 반복문을 종료한다. 슬라이싱 길이가 m 이 되지 않는지를 판단하는 기준은 현재 for 문의 시작 인덱스에서 m 을 더한 값이 score 길이보다 큰지다.

슬라이싱을 시작 인덱스 ~ 시작 인덱스 + m - 1 까지 하기 때문에 시작 인덱스 + m 이 score 의 길이와 같은 것은 괜찮다. 그러나 score 길이보다 크면 m 개보다 적은 갯수로 슬라이싱이 되므로 슬라이싱하면 안 된다.
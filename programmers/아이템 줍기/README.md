# 프로그래머스

## 아이템 줍기

BFS 를 활용해서 풀이했다.

다른 분들의 풀이를 보니 주로 테두리 영역만 1로 표시하는 방법을 선택 했으나 첫번째 풀이는 이 방법 대신 다른 방법을 선택했다.

모든 사각형 영역을 1로 표시한 후 해당 영역이 테두리인지 판단해서 테두리인 경우만 이동하는 방법을 선택했다.

<br>

### 첫번째 풀이

테두리 영역만 1로 표시하지 않고 직사각형을 모두 1로 표시했다. 직사각형을 탐색할때 테두리 여부를 판단해서 탐색을 진행했다.

한 좌표에서 이동 가능한 8방향의 좌표 중 하나라도 이차원 리스트 범위를 벗어나거나 직사각형을 벗어나면 테두리에 있다고 판단했다. 

이동 가능한 8방향의 좌표 중에서 하나라도 이차원 리스트를 벗어난다는 것은 기준 좌표가 이차원 리스트의 가장 자리에 있다는 뜻이다. 이동 가능한 8방향의 좌표가 하나라도 직사각형 바깥에 있으려면 기준 좌표가 직사각형의 테두리에 있어야 한다.

<br>

```python
rectangle = [[1, 1, 5, 3], [3, 1, 5, 4], [2, 4, 5, 6]]
```



```
0 0 0 0 0 0 0
0 1 1 1 1 1 0
0 1 0 0 0 1 0
0 1 1 1 0 1 0
0 0 1 1 0 1 0
0 0 1 0 0 1 0
0 0 1 1 1 1 0
```

좌표는 1부터 50까지 주어지는데 이차원 리스트의 크기를 101로 설정했다. 이차원 리스트에 직사각형을 표시하면 실제로는 연결되지 않았는데 마치 연결된 것처럼 나타나서 정확한 탐색을 할 수 없다.

rectangle 이 위와 같이 주어지고 테두리를 1로 표시하면 위와 같다. (3,2) 에서 (4,2) 는 연결되지 않은 길인데 이차원 리스트에는 연결된 것처럼 나타나게 된다. (3,2) 에서 (4,2) 로 가려면 (3,2) -> (3,3) -> (4,3) -> (4,2) 로 가야하는데 마치 (3,2) 에서 (4,2) 로 바로 갈 수 있을 것처럼 나타난다.

(3,2) 에서 BFS 로 인접 영역을 탐색하면 (4,2) 가 포함되기 때문에 이를 방지하고자 좌표 값을 2배씩 증가시켰다. 증가한 좌표를 이차원 리스트에 담기 위해 이차원 리스트의 크기를 101로 했다. 최대 좌표가 50이라 이를 2배 증가하면 100이 되기 때문에 100을 그대로 인덱스로 사용하기 위해 이차원 리스트의 크기는 101이다.

<br>

좌표를 2배로 늘렸기 때문에 거리도 2배가 됐다. 리턴할 때는 거리에서 2를 나눈 몫을 리턴해야 한다.

<br>

### 두번째 풀이

이차원 리스트에 모든 직사각형을 1로 표시하지 않고 테두리만 1로 표시하는 방법으로 풀이했다. 

y 축이과 x 축이 모두 맨 처음이나 맨 끝 값이 아니면 테두리가 아니다. 그런데 y 축이나 x 축이 하나라도 맨 처음이나 맨 끝 값이라도 무조건 1로 표시하면 안 된다. 다른 테두리의 내부 영역인 경우는 제외하고 1로 표시해야 한다.

이차원 리스트를 -1로 초기화 하고 테두리는 1, 테두리의 내부는 0으로 표시한다.

<br>

첫번째 풀이와 마찬가지로 좌표를 2배로 늘리고 이차원 리스트의 크기는 101로 했다. BFS 탐색을 한 후 거리에서 2를 나눈 몫을 리턴한다.

<br>

<참고>

https://velog.io/@leeeeeyeon/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%95%84%EC%9D%B4%ED%85%9C-%EC%A4%8D%EA%B8%B0


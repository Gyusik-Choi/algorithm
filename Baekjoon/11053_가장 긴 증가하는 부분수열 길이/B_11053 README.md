# 백준

## 11053

유명한 알고리즘 문제다.

### 첫번째 풀이

n^2의 시간복잡도를 갖는다.

자신보다 앞에 있는 배열을 요소들을 모두 검사해야 한다.

자신보다 작은 요소 중에서 최장 부분수열 길이를 갖는 값에서 1을 더해주는 방식으로 답을 구해갔다.

<br>

더 깊이있게 이해할 수 있도록 첫번째 풀이에 대한 정리 외에 따로 추가적으로 정리해보려고 한다.

<br>

### 두번째 풀이

첫번째 풀이에서는 dp 배열에 모두 0을 집어넣었다. 이로 발생했던 문제는 각 dp 배열의 모든 요소들은 최소값이 0이 아닌 1이라서 최소값이 1인지 여부를 따로 변수를 만들어서 체크해야 했다.

즉 안쪽 for문을 실행하면서 max_cnt = 1로 설정해두고, 안쪽 for문을 모두 실행한 후에도 max_cnt가 1인지를 마지막에 체크해야 한다.

max_cnt가 1이다는 것의 의미는 가장 작은 숫자 값이다는 것인데 dp 배열을 처음에 모두 1로 세팅함으로써 max_cnt를 사용하지 않아도 됐다.

그리고 max_cnt 값이 증가할때마다 새롭게 갱신을 해줘야 하는데 두번째 풀이에서는 max_cnt를 사용하지 않기 때문에 max_cnt를 갱신해주는 코드도 필요없어졌다.

<br>

두번째 풀이도 이중 반복문을 돌아야해서 n^2의 시간복잡도를 갖는데 이진탐색을 통해서 nlogn으로 시간복잡도를 줄일 수 있어서 현재 이를 공부중이다. 풀이를 완료하는데로 다시 정리할 계획이다.
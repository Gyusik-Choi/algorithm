# 백준

## 11053

유명한 알고리즘 문제다.

### 첫번째 풀이

n^2의 시간복잡도를 갖는다.

자신보다 앞에 있는 배열을 요소들을 모두 검사해야 한다.

자신보다 작은 요소 중에서 최장 부분수열 길이를 갖는 값에서 1을 더해주는 방식으로 답을 구해갔다.

<br>

더 깊이있게 이해할 수 있도록 첫번째 풀이에 대한 정리 외에 따로 추가적으로 정리해보려고 한다.

<br>

### 두번째 풀이

첫번째 풀이에서는 dp 배열에 모두 0을 집어넣었다. 이로 발생했던 문제는 각 dp 배열의 모든 요소들은 최소값이 0이 아닌 1이라서 최소값이 1인지 여부를 따로 변수를 만들어서 체크해야 했다.

즉 안쪽 for문을 실행하면서 max_cnt = 1로 설정해두고, 안쪽 for문을 모두 실행한 후에도 max_cnt가 1인지를 마지막에 체크해야 한다.

max_cnt가 1이다는 것의 의미는 가장 작은 숫자 값이다는 것인데 dp 배열을 처음에 모두 1로 세팅함으로써 max_cnt를 사용하지 않아도 됐다.

그리고 max_cnt 값이 증가할때마다 새롭게 갱신을 해줘야 하는데 두번째 풀이에서는 max_cnt를 사용하지 않기 때문에 max_cnt를 갱신해주는 코드도 필요없어졌다.

<br>

두번째 풀이도 이중 반복문을 돌아야해서 n^2의 시간복잡도를 갖는데 이진탐색을 통해서 nlogn으로 시간복잡도를 줄일 수 있어서 현재 이를 공부중이다. 풀이를 완료하는데로 다시 정리할 계획이다.

<br>

### 세번째 풀이 + 네번째 풀이

이진 탐색을 활용한 풀이다. 이진 탐색을 왜 사용해야 하는지 이해하는데 시간이 오래걸렸다. 왜냐하면 이 방식이 lis 길이는 찾을 수 있지만 정확한 lis 값을 갖는다고는 말하기 어렵다.

5 6 7 1 2 가 있으면 이진 탐색으로 풀이를 하게 되면 lis는 1 2 7 이 된다. 이를 받아들이는데 시간이 오래걸렸다고 보는게 더 적절할 것 같다.

lis는 항상 오름차순으로 유지가 되면서 lis의 마지막 값보다 주어진 값이 더 크면 lis 마지막에 추가하고, lis 마지막 값보다 같거나 작으면 이진 탐색을 통해 값을 수정할 인덱스를 찾는다. 이때 이진탐색을 통해 선형으로 탐색하는 것보다 훨씬 빠르게 탐색이 가능하다. 매번 범위를 절반씩 줄여나가기 때문에 logN의 시간복잡도로 탐색하게 된다.

이진 탐색도 기존에 특정 값을 찾는 경우로 주로 사용했다보니 이번에 찾는 방식과 조금 달라서 재귀적인 방식을 사용할때 탈출 조건을 설정하거나 전체 코드를 구성하는게 어려웠다.

start가 end 보다 크거나 같으면 end 값을 리턴하도록 했다. start가 end보다 커지는 경우가 생기는지는 불확실하지만 커지면 아예 탐색 범위를 벗어나기 때문에 end를 리턴하도록 탈출 조건을 설정했다. 그리고 중간 인덱스인 mid를 설정하여 중간 인덱스의 값보다 대상 값이 더 크면 중간보다 우측에 대상 값이 위치할 수 있으므로 start를 mid + 1로 수정했다. 중간 인덱스의 값과 대상 값이 같을 경우에는 mid 값을 리턴했고 중간 인덱스의 값이 대상 값보다 더 크면 end를 mid로 수정했다. 이때 end = mid - 1을 하면 안 된다. start 가 0이고 end 가 1이었을때는 mid 가 0이라서 end 를 mid - 1로 하면 인덱스가 맞지 않게 된다.

<br>

추후에 정확한 lis 값을 요구할때는 풀이를 어떻게 해야할지 궁금하다. 백준에서 이 문제도 곧 만나길 기대해본다.

<br>

참고

https://chanhuiseok.github.io/posts/algo-49/
https://shoark7.github.io/programming/algorithm/3-LIS-algorithms
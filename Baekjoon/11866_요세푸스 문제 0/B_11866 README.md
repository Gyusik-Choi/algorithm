# 백준

## 11866

### 풀이1

풀이법이 다양하게 있는 듯해서 추가적으로 풀어볼 계획이다.

visited 배열로 제거한 숫자를 표시하고 last_index 변수로 마지막으로 뽑은 숫자가 무엇인지 판단한다. 그리고 numbers 배열에는 뽑은 숫자를 집어넣어서 추후에 마지막 숫자 하나만 남았는지 numbers 배열의 길이를 기준으로 판단한다. 이를 통해 하나 남은 숫자를 바로 numbers에 집어넣고 while문을 종료할 수 있도록 한다.

이중 while 문으로 구성해서 숫자를 다 제거할 때까지 바깥 while문은 반복된다. 안쪽 while문은 K - 1회를 기준으로 반복된다. last_index 정보를 받는 idx 변수값을 시작점으로 반복되고 idx 변수값은 원형큐의 아이디어를 활용했다. 즉 idx를 1씩 올려나가되 N보다 커지지 않도록 N을 나눈 나머지 값을 구했다. 

idx에 해당하는 숫자(실제 숫자는 idx 보다 1 크다)가 제거한 숫자면 횟수를 감소시키고 그렇지 않으면 감소시키지 않는다. 이렇게 해서 안쪽 while문이 돌고 나면 numbers 배열의 길이가 N - 1 보다 작으면 아직 제거할 숫자가 2개 이상 남았다는 의미라서 while문이 끝나면 안 된다. while문을 끝내지 않고 visited 배열의 해당하는 idx를 제거 표시 하고 numbers 배열에는 idx 보다 1 큰 숫자를 넣어서 실제 제거하는 숫자가 들어가도록 한다. 

그리고 다음 시작점을 찾아야 한다(이 부분이 시간 소요가 많이 됐다. 다음 시작점을 찾는 코드 자체가 아니라 다음 시작점을 어떻게 구성해야할지 이해하는데 시간이 걸렸다). 다음 시작점은 마지막으로 제거한 숫자 다음의 아직 제거하지 않은 숫자다. 그 숫자를 기준으로 while 문이 다시 돌아야 한다. 

numbers 배열의 길이가 N - 1이 될 때까지 while문을 반복하다가 마지막 남은 숫자를 numbers 배열에 넣어주고 while문을 종료한다.

<br>

### 풀이2

배열의 맨 앞의 숫자를 빼서 뒤로 보내는데 K - 1번째라면 뒤로 보내지 않고 숫자를 빼기만 한다. K - 1번째의 숫자가 제거해야할 K번째의 숫자이기 때문이다. 이를 numbers 배열에서 숫자를 모두 제거할 때까지 반복한다.

<br>

### 풀이3

풀이2에서 수행한 배열에서 숫자를 빼고 다시 넣는 방식은 매번 배열이 재배치되야해서 풀이3보다 비효율적이다.

풀이3에서는 기준점에서 K - 1을 더하고 이를 배열의 길이로 나눈 나머지 값에 해당하는 인덱스의 숫자를 배열에서 제거한다. 이때 주의할 점은 배열의 길이를 N으로 고정하는게 아니라 숫자를 제거할 때마다 이에 맞춰서 나누는 값을 현재 배열의 길이로 변경해야 한다. 배열은 크기가 작아지는데 N으로 계속 나누게 되면 인덱스가 배열의 크기를 넘어가기 때문이다.
# 백준

## 1912

동적계획법은 이전 값을 활용해서 계산 횟수를 줄이는 장점이 있다.

이전 값이라는게 단순히 바로 이전이 아니라 현재보다 이전의 값이 누적되온 총합이다.

이 점을 조금더 생각했다면 해결 방법에 조금 더 근접할 수 있었을듯 한데 아쉽게도 다른 분들의 코드를 보고 파악할 수 있었다.

<br>

1 4 -3 2

이 상황에서 최대값은 5다.

1 4 -2 3

이 상황에서 최대값은 6이다.

<br>

위의 경우는 1, 4에서 -3을 빼지 않아야 더 큰 값이 나오고, 아래의 경우는 -2를 빼고 3까지 더해야 더 큰 값이 나온다.

위의 경우를 작성한 코드를 바탕으로 보면 1, 5, 2, 4가 된다. 1은 그대로 1로 시작하고 4를 만나면 1과 4를 더하는 것과 4 중에서 더 큰 값을 선택한다. 전자가 더 커서 5가 된다. 5에서 -3을 뺀 값과 -3 중에서 더 큰 값은 전자라서 2가 된다. 2와 2를 더한 값과 2 중에서도 전자가 더 크므로 4가 된다.

아래의 경우는 1, 5, 3, 6이 된다. 1은 그대로 1로 시작하고 1과 4를 더한 값이 4보다 더 작기에 5가 된다. 그 다음은 5와 -2를 더한 값이 -2 보다 크므로 3이 된다. 3과 3을 더한 값은 3보다 더 크므로 6이 된다.

예시를 조금 더 추가해보면

-1 -2 3

이런 경우가 있다고 하면 -1, -1, 3이 된다.

마지막 숫자인 3을 보면 이전까지 누적합의 최대는 -1이다. -1에서 3을 더하는 것 보다는 이전까지의 값을 버리고 3을 택하는게 더 크다.

즉 이전 까지의 값과 현재 값을 더한 것 보다 현재 값이 더 크면 이전까지의 값을 버리고 새롭게 시작할수 있다.

<br>

이 부분을 제대로 생각하지 못했다. n ^ 2 풀이 방식을 사용했을때 정답은 찾는듯 했으나 역시나 시간 초과로 백준 사이트에서는 통과할 수 없었다. n ^ 2 풀이 방식을 썼던 이유는 어느 지점이 최대 값을 찾게 되는 시작점인지를 알 수 없어서 n개의 숫자가 있다고 하면 0번 인덱스부터 n - 1(끝)까지, 1번 인덱스부터 n - 1까지, 2번 인덱스부터 n - 1까지... 이런 식으로 모든 시작점을 검사하려했다.



참고

https://sihyungyou.github.io/baekjoon-1912/

https://mygumi.tistory.com/97
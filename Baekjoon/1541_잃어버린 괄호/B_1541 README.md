# 백준

## 1541

괄호를 적절하게 만들어서 최소 값을 만들어야 하는 문제다. 최소 값을 만들기 위해서 마이너스(-) 다음에 + 가 나온다면 먼저 연산을 해줘야 한다.

입력을 받고 연산자와 숫자를 따로 배열을 만들어서 모았다. 그래서 연산자의 인덱스를 기준으로 숫자를 계산했다. 즉 연산자 인덱스가 0이면 숫자의 인덱스 0과 1을 계산하는 방식이다.

예를 들어 55 - 50 + 40 - 30일 경우에 ['-', '+', '-'], [55, 50, 40, 30] 이렇게 배열을 구성했고 계산한 값은 [0, 0, 0, -65] 이렇게 저장하여 맨 마지막 값을 출력했다.

위에 예시로 제시한 55 - 50 + 40 - 30 는 55 - ( 50 + 40 ) - 30 이렇게 계산을 하려고 했다. 먼저 - 다음에 + 가 나오는 경우를 찾아서 연산을 처리해줬다. 55 - (90 + 0) - 30 이렇게 계산을 해서 앞부분에 연산을 한 결과를 넣고 뒤에는 0을 넣어줬다. 그 다음에는 하나씩 연산을 해나갔다.

한 가지 간과했던 부분이 있었는데 예를 들어 55 - 50 + 40 + 30 이런 경우에는 55 - (50 + 40 + 30) 이렇게 괄호를 쳤어야 했는데 위의 방식대로는 55 - (50 + 40) + 30 이렇게 괄호가 돼서 오답이 나왔다. 이를 해결하기 위해 방식을 바꿔야 했다.

연산자가 -가 나오면 해당 연산자가 갖는 배열의 인덱스에서부터 마지막까지 while 문을 돌면서 +가 나오는 경우에 계속 연산을 해나갔다. 다만 이때는 아까와는 달리 연산한 값을 앞이 아닌 뒤에 저장해야 했다. 그래야 연속으로 연산을 해야할 경우에도 연산을 할 수 있기 때문이다. 즉 55 - (50 + 40 + 30) 일때 55 - (90 + 0 + 30) 이렇게 되는게 아니라 55 - (0 + 90 + 30) 이렇게 해서 90과 30도 계산을 할 수 있도록 해야 했다. 55 - (0 + 0 + 120) 이렇게 while문을 돌면서 만들어나갔다. 

다만 이대로 끝내면 55와 30을 더해버리는 결과가 나오기 때문에 30을 다시 맨 앞으로 가져와야 했다. 주의할것은 -를 만났다고 뒤에 +가 항상 나오는게 아니기 때문에 연산이 이루어지지 않았을 수도 있다. 이때는 연산도 하지 않은 숫자를 앞으로 가져와 버리는 결과가 나올 수 있기 때문에 flag 변수를 지정해서 연산이 이루어진 경우에만 뒤에 저장된 숫자를 앞으로 가져왔다. 위의  55 - (0 + 0 + 120)의 상황에서는 55 - (120 + 0 + 0) 이렇게 바꿔주는 것이다.

그리고는 하나씩 연산을 해나가면서 0, -65, 0, 0 에서 0, 0, -65, 0 으로, 그리고 0, 0, 0, -65 가 되면서 연산이 종료되고 맨 마지막 값인 -65를 출력한다.




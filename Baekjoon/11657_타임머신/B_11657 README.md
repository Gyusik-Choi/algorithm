# 백준

## 11657

벨만포드 알고리즘을 활용하는 문제다.

다익스트라처럼 특정 정점을 기준으로 나머지 모든 정점에 대한 최소거리를 구한다.

다만 다익스트라와 달리 음의 순환을 찾을 수 있다. 

다익스트라는 이미 탐색한 정점은 제외하고 나머지 정점으로부터 연결된 정점간의 거리를 갱신해나가는데, 벨만포드는 정점의 개수만큼 모든 간선에 대해서 거리를 갱신해나간다. 정점의 개수 - 1회는 최소거리를 갱신하기 위한 과정이라면 1회는 음의 순환을 찾기 위한 과정이다.

<br>

벨만포드 알고리즘이 제대로 이해가 되지 않아서 [질문](https://www.acmicpc.net/board/view/74846#comment-123110) 을 남겼고 감사하게도 좋은 답변을 받아서 이해하는데 많은 도움이 됐다.

입력이

```
4 3
3 4 5
2 3 5
1 2 5
```

1 -> 2 -> 3 -> 4 이렇게 경로가 주어졌다. 1부터 가는 최단 경로를 구하는데 주어진 입력이 최적의 순서로 주어지지 않았기 때문에 한번의 탐색으로 최단 경로를 구할 수 없다. 

```python
routes = []
for i in range(3):
  s, e, v = map(int, input().split())
  routes.append([s, e, v])

INF = float('inf')
distance = [INF] * (4 + 1)
distance[1] = 0
```

1번 정점에서 나머지 정점들 간의 최단 경로를 구하기 위한 세팅을 마치고 나서 한번의 최단 경로를 구하는 탐색을 해보자.

```python
for i in range(1):
  for j in range(4):
    start = distance[j][0]
    end = distance[j][1]
    value = distance[j][2]
    
    if distance[start] != INF and distance[end] > distance[start] + value:
      distance[end] = distance[start] + value
```

입력 순서에 따라서 먼저 3 4 5 는 distance[3]이 INF라 갱신되지 못하고, 2 3 5도 distance[2]가 INF라 갱신되지 못한다. 그리고 1 2 5 만 distance[1]이  0이라서 갱신될 수 있다. 갱신하고 나면 distance 배열은 [INF, 0, 5, INF, INF]이 된다.

한번 더 최단 경로를 구하는 탐색을 하면, 3 4 5는 갱신되지 못하고, 2 3 5와 1 2 5는 갱신된다. distance 배열은 [INF, 0, 5, 5, 0]이 된다.

마지막으로 한번 더 수행하면 distance 배열은 [INF, 0, 5, 5, 5]가 된다.

**이런 이유로 정점의 갯수가 N이면 최단 경로 갱신을 위한 탐색을 N - 1 회를 수행해야 한다.**

N - 1회를 통해 사이클 없이 최단 거리를 모두 갱신이 가능하고, 1번 더 탐색을 수행하더라도 최단 거리의 갱신이 일어나지 않는다. 다만 음의 순환이 있다면 이때도 최단 거리의 갱신이 일어날 것이므로 N - 1회의 탐색 이후 1회의 탐색을 통해 음의 순환 여부를 알 수 있다.

단, 무조건 음수 간선이 있다고 음의 순환이 일어나진 않는다. 이는 이 [영상](https://www.youtube.com/watch?v=Ppimbaxm8d8) 을 참고하면 이해하는데 많은 도움이 될 것이다.


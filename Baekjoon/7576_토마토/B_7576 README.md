# 백준

## 7576

BFS 문제다. 시간초과가 계속 걸렸다.

해결 방법으로 공간의 크기를 우선 줄였다.

애초에 토마토 정보를 받는 박스 배열 외에 방문 처리를 위한 배열을 박스 크기 만큼 생성했으나 최대 박스 크기가 1000 X 1000인 100만 크기라 하나 더 있으면 공간을 많이 차지하므로 하나의 배열로 처리하고자 했다.

이를 위해 박스 배열에 직접 방문 처리와 날짜를 알 수 있도록 계산해나갔다. 이때 조건문에 필요한 경우의 수(방문 배열이 있으면 방문을 했는지 여부, deque에 이미 들어가있는지 여부)를 하지 않아도 됐다. deque에 중복 여부를 검사하는 것은 not in으로 해야했기에 O(n)만큼 드는 꽤 시간이 소요되는 부분이었는데 박스 자체의 숫자를 올려버려서 0이 아닌 박스들은 당연히 deque에 들어가지 못하므로 체크할 필요가 없어졌다.

deque를 다 돌고나서 0이 있는지 체크하여 0이 나오면 바로 -1을 리턴하도록 해서 최대한 for문을 적게 돌려고 했다.

그렇지만 어쨌든 이중 for문을 두번(한번은 0이 어디에 있는지 체크하기 위해서, 다른 한번은 0이 남아있는지 체크하기 위해서) 돌아야해서 이 부분 때문에 이게 왜 더 빠른지 문제를 통과하자마자 정리하는 현재 시점에서는 정확히 와닿지는 않는다.

이중 for문을 가능한 한번만 돌려고 했으나 이중 for문을 한번만 돌기 위해서 처리해야 했던 것들의 오버헤드가 더 컸던것 같다.

<br>

BFS, DFS(재귀 아닌 스택 방식)를 풀이할때 큐나 스택에 검사하고자 하는 요소가 이미 들어있는지를 체크할 필요가 없는 경우는 해당 요소를 추출하는 대상의 숫자를 직접 변경할때다. 예를 들어 0인 요소를 큐나 스택에 넣으려고 하는데 이미 큐나 스택에 들어와있는지 아닌지를 체크할 필요가 있는 경우는 0을 갖는 대상의 숫자를 직접 변경하지 않고 따로 방문 배열등을 두어서 처리하는 경우다. 방문 배열에다가 숫자를 바꾸기 때문에 기존 대상의 숫자는 바뀌지 않고 남아있어서 반복적으로 같은 위치의 요소가 큐나 스택에 들어갈 수 있다.

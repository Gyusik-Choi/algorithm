# 백준

## 2887

첫 제출에서 메모리 초과가 발생했다. 원인을 제대로 파악하지 못하고 정렬을 우선순위 큐로 대신해서 수행해보았으나 마찬가지로 메모리 초과가 발생했다. 메모리 초과의 원인은 좌표를 구할때 n^2으로 구한 점이다. 행성의 개수로 주어질 수 있는 최대 숫자가 10만이고, n^2으로 하게 되면 10만의 제곱이 되어서 메모리 초과가 발생할 수 있게 된다.

그래서 좌표를 구하는 방법을 바꿔야 했다. 다른 분의 글을 참고하여 해결할 수 있었다. 먼저 x, y, z 좌표와 인덱스를 개별적으로 구한 다음에 x, y, z를 각각 정렬을 시킨다. 이렇게 되면 x, y, z는 각각 가장 인접한 행성들끼리 정렬되는 것이다.

```
1 100 30 10 5
```

이런 식으로 x좌표가 주어졌다고 하면 [[1, 0], [5, 1], [10, 2], [30, 3], [100, 4] 이렇게 정렬한다. 인덱스는 추후에 disjoint-set 연산을 위한 인덱스 정보로 활용한다.

x, y, z를 인접한 행성들끼리 각각 정렬한 다음에 하나의 배열에 [비용, 좌표1, 좌표2] 정보를 넣는다. 비용은 x를 기준으로 1번째 인덱스의 행성 - 0번째 인덱스의 행성, 2번째 인덱스의 행성 - 1번째 인덱스의 행성 ... N번째 인덱스의 행성 - N-1번째 인덱스의 행성 이렇게 구하면 된다.

하나의 배열에는 3N개의 [비용, 좌표1, 좌표2]에 대한 정보가 담기는데 이를 정렬하면 x, y, z 관계 없이 거리가 가장 가까운 순서로 정렬된다.

입력되는 최대 행성의 수가 그리 크지 않았다면 3N과 N^2이 그리 큰 차이가 나지 않을 수 있으나 이번 문제에서는 최대 행성의 수가 10만이라서 3N과 N^2의 차이가 크게 발생한다.

<br>

x, y, z를 각각 구하면 겹치는 경우가 발생하는 부분은 어떻게 처리해야 할지를 고민했지만 이는 걱정할 필요가 없었다. 즉 x, y, z 모두 같은 인덱스 정보를 갖는 값일경우 - 예를 들어 x, y, z 모두 1, 2 인덱스가 맨 앞에 있으면 3개가 모두 하나의 좌표 간선에 대한 정보가 된다 - 를 걱정하지 않아도 된다. 루트를 조회하는 연산(find)에 의해서 이미 union 연산이 되었으면 앞에서 언급한 3개가 모두 들어가지 않고 하나만 들어간다.

<br>

참고

 https://chanhuiseok.github.io/posts/baek-34/
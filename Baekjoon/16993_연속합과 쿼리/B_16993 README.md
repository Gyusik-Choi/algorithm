# 백준

## 16993

세그먼트 트리를 활용하는 문제고, 어려운 문제였다. 

이것이 코딩테스트다의 금광 문제를 보다가 알게된 문제다. [이분](https://viyoung.tistory.com/149) 의 코드를 거의 그대로 파이썬으로 옮겨서 풀이했다.

단순히 특정 구간의 연속합만 구하는 것이 아니라 특정 구간 내에서 최대 연속합을 구하는 문제다.

예를 들어 4개의 연속 구간에서 답을 구할 때, 이 문제에서는 4개 구간의 합을 단순히 구하는게 아니라 4개의 구간에서 최대로 나올 수 있는 연속합을 구해야 한다.

분할정복으로 세그먼트 트리를 구성하되 최대 연속합을 구하기 위해 DP를 통해 맨 아래 노드에서 구한 최대 값들을 상위 노드로 올라오면서 활용해야 한다.

최대 연속합을 구하기 위해서 4개의 노드(1, 2, 3, 4)가 있다고 하면 최대 연속합으로 나올 수 있는 경우의 수는 (1), (2), (3), (4), (1, 2), (1, 2, 3), (1, 2, 3, 4), (2, 3), (2, 3, 4), (3, 4) 다.

어느 구간이 최대 연속합인지 알 수 있도록 맨 아래 노드부터 최대 값(max_val)을 구해서 올라와야 한다. 이를 위해 Node 클래스에서 왼쪽 최대합, 오른쪽 최대합, 최대합, 총합 4개의 값을 갖는다.

맨 아래 노드는 왼쪽 최대합, 오른쪽 최대합, 최대합, 총합이 모두 동일한 자기 자신의 값을 갖는다. 

<br>

간과한 부분이 있었다. 왼편 노드의 왼쪽 최대합과 오른편 노드가 오른쪽 최대합이 최대합을 구하는데 필요한걸까 하는 생각이 있었는데 만약에 왼편 노드가 트리의 맨 왼쪽이고, 오른편 노드가 트리의 맨 오른쪽이면 이는 맞다. 그러나 왼편 노드가 트리의 맨 왼쪽에 있지 않으면 오른쪽 노드가 될 수도 있거나 오른편 노드가 맨 오른쪽에 있지 않으면 왼편 노드의 왼쪽 최대합과 오른편 노드가 오른쪽 최대합은 최대합을 구하는데 필요하다.

max_val = max(max(front.max_val, back.max_val), front.right + back.left) 에서 왼편 노드가 추후에 오른편 노드가 되면 front.left 는 back.left 가 될 것이고 이때는 left 값이 max_val 을 구하는데 필수적이다. 

<br>

<참고>

https://kth990303.tistory.com/204

https://viyoung.tistory.com/149
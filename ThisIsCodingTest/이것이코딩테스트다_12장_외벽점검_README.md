# 이것이 코딩테스트다

## 챕터 12 14번 외벽점검

카카오 코딩테스트 기출문제로 구현 유형의 문제다. 굉장히 어려운 문제였다.

첫 풀이에서는 취약 지점을 기준으로 for 문을 돌면서 한 취약 지점을 시작점으로 했다. 그리고 시계 방향과 반시계 방향 탐색으로 나눠서 점검 길이가 긴 순서대로 for 문을 돌면서 가장 빠르게 점검을 마치는 값을 정답으로 하려했다.

이 풀이의 문제점은 점검 길이가 긴 순서대로 탐색을 하다보니 보다 짧은 점검 길이로 탐색 해야할 경우를 놓치게 된다. 

예를 들어, solution(300, [0, 10, 50, 80, 150, 160, 210, 250], [40, 30, 10, 10, 5, 1]) 이런 입력이 주어지면 취약 지점 210 ~ 250을 점검 길이 40, 취약 지점 0 ~ 10을 점검 길이 10, 취약 지점 50 ~ 80을 점검 길이 30, 취약 지점 150 ~ 160을 점검 길이 10으로 탐색해야 최소 값을 찾을 수 있다. 그러나 위의 풀이 방식으로는 40 30 10 10 이런 순서로만 진행되다보니 이 경우를 충족하지 못한다.

이 풀이 방식으로 14번 테스트 케이스만 오답이 났는데 아마 이와 유사한 입력이 존재했을 것이라고 생각한다.

<br>

풀이법을 바꿔야 했고 [이분](https://velog.io/@tjdud0123/외벽-점검-2020-카카오-공채-python)의 코드를 참고했다. 점검 길이가 긴 순서대로 for 문을 돌고 취약 지점을 기준으로 안쪽 for 문을 돌면서 한 취약 지점마다 갈 수 있는 모든 경우의 수를 구한다. 그리고 이를 누적해서 취약 지점의 갯수와 같아지면 정답으로 했다. 앞에서 언급한 풀이가 그리디하게 접근했다면 이 풀이는 그리디하면서 모든 경우의 수를 고려하기 때문에 통과할 수 있었다.

<br>

<참고>

https://velog.io/@tjdud0123/외벽-점검-2020-카카오-공채-python

이것이 코딩테스트다
# 이것이 코딩테스트다

## 챕터 15 27번 정렬된 배열에서 특정 수의 개수 구하기

### Python

시간 복잡도 O(logN) 으로 해야한다는 조건이 있어서 선형 탐색으로는 시간 초과가 발생하는 문제다. 이진 탐색을 활용해야 한다.

찾아야할 수의 가장 왼쪽 인덱스와 가장 오른쪽 인덱스를 구하기 위해 두 개의 이진 탐색 함수를 작성했다. 가장 왼쪽 인덱스를 찾기 위해서 찾아야할 수의 바로 왼쪽 인덱스가 찾아야할 수 보다 작아야 하고, 가장 오른쪽 인덱스를 찾기 위해서 찾아야할 수의 바로 오른쪽 인덱스가 찾아야할 수 보다 커야 한다.

가장 오른쪽 인덱스를 찾을 때 인덱스 에러가 발생하지 않도록 인덱스 + 1 이 배열의 인덱스를 넘어가지 않는지 체크하기 위해 mid 가 N - 1 인지 체크하는 조건을 추가로 달았다. 가장 왼쪽 인덱스를 찾을 때는 파이썬에서 음수 인덱스가 있기 때문에 인덱스 에러가 발생하지 않으나 다른 언어로 풀었을 때도 같은 결과를 낼 수 있도록 로직 자체에는 mid 가 0 인지 체크하는 로직을 추가했다.

<br>

#### 4번째 풀이

수열이 오름차순으로 정렬된 채로 나온다. 이진탐색으로 대상 숫자를 찾게되면 찾은 숫자의 인덱스를 기준으로 왼쪽과 오른쪽으로 선형 탐색을 통해 대상 숫자의 총 갯수를 구했다.

<br>

#### 5번째 풀이

4번째 풀이 방법이 선형 탐색이 포함돼서 좋지 못한 풀이라고 느껴졌다. N 이 1,000,000 이고, x 와 원소들이 모두 같은 값이라고 하면 선형으로 1,000,000 회를 탐색해야 한다.

시작 인덱스와 끝 인덱스를 구해서 갯수를 구하는 방식으로 풀이했다.

<br>

### JavaScript

#### 1번째 풀이

숫자 x 를 찾고 찾은 지점을 기준으로 양쪽 방향 이진 탐색을 추가로 실시해서 x 가 추가로 더 있는지 탐색한다.
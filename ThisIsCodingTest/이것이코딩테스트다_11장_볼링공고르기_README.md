# 이것이 코딩테스트다

## 챕터 11 5번 볼링공 고르기

그리디 알고리즘 문제다.

### 1번 풀이

N개의 숫자에서 2개를 선택하는 횟수는 1부터 N - 1을 모두 더한 값이다.

이를 활용해서 2개를 선택하는 횟수를 구한 후에 겹치는 숫자들끼리 선택하는 횟수를 빼는 방법으로 풀이했다.

겹치는 숫자를 구하는 방법이 비효율적이어서 아쉬웠다.

<br>

### 2번 풀이

1번에서 아쉬웠던 겹치는 숫자를 구하는 방법을 개선했다.

카운팅 정렬에서 쓰는 방법을 활용했다. 1부터 N까지의 숫자를 인덱스로 하는 배열을 만들고 초기 값을 모두 0으로 둔다. 숫자 목록을 for 문으로 돌면서 나오는 숫자에 해당하는 인덱스 배열의 값을 1씩 더했다.

<br>

### 3번 풀이

하나의 숫자당 구할 수 있는 조합은 남아 있는 숫자의 갯수 - 1이다.

N이 아니라 남아 있는 숫자라고 한 이유는 예를 들어 1에 대한 조합을 구하고 나면 1을 제외시켜줘야 한다. 1을 제외시키지 않으면 경우의 수가 겹치게 된다. 1, 2, 3, 4, 5가 있는데 1은 1, 2/ 1, 3/ 1, 4/ 1, 5 조합을 구할 수 있고 2를 구할때 2, 1/ 2, 2/ 2, 3/ 2, 4/ 2, 5 이렇게 된다. 1, 2와 2, 1은 같은 경우기 때문에 겹친다. 이를 막기 위해 조합을 구한 수는 빼줘야 한다.

각 숫자별 갯수를 구하고, for 문을 돌면서 N에서 for 문 요소의 갯수를 빼준 다음 N과 for 문 요소의 갯수를 곱해준다.

1, 2, 2, 3, 3은 [1, 2, 2] 갯수를 가지고 [1, 2, 2]의 반복문을 돌면서 N에서 반복문 요소의 값을 빼주고 N에서 요소의 값을 곱해준 총합을 구하면 된다.

N과 요소의 값을 곱해주는 이유는 예를 들어 1 2 2 3 3에서 2는 2개가 있는데 이들의 조합은 각각 3개씩이다. 1번 인덱스의 2도 3개, 2번 인덱스의 2도 3개다. 그래서 N - 2를 해주고 N과 2를 곱해준다.

<br>

### 4번 풀이

조합을 활용해서 풀이했다. 조합의 경우를 구하는 배열이 비어있으면 볼링공을 바로 넣고, 볼링공이 있으면 배열에 있는 볼링공 인덱스 보다 현재 볼링공의 인덱스가 더 크면서 볼링공의 번호가 같지 않으면 배열에 넣어준다.


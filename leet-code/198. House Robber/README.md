# LeetCode

## [198. House Robber](https://leetcode.com/problems/house-robber/)

### Python

다이나믹 프로그래밍 유형의 문제다.

타뷸레이션, 메모이제이션을 활용해서 풀이했다. 이 문제는 피보나치 수를 구하는 방식과 유사하게 접근할 수 있다.

<br>

#### 타뷸레이션

교재는 상향식 풀이를 타뷸레이션으로 정의한다. for 문을 이용해서 작은 수의 결과를 구하고 이 결과를 활용해서 보다 큰 수의 결과를 구하면서 n 의 값을 구한다.

거리 2의 집의 값에서 현재 집의 값을 합과 거리 1의 집의 값 중 큰 값을 현재 집의 값으로 한다. 거리1의 값은 현재 집의 값과 맞닿아 있는 집이라 현재 집의 값과 더하지 않는다. 이 방식으로 현재 집의 최대 값을 누적해나갈 수 있다. 현재 집에서는 거리1의 집의 값을 가져올 수 있으나 현재 집과 더하지만 않으면 된다. 거리1의 집은 현재 집의 다음 집에서 거리1의 집과 더한 합을 현재 집의 값과 비교할 수 있다.

<br>

#### 메모이제이션

재귀를 활용해서 풀이하되 동일한 값을 반복해서 구하지 않기 위해 한번 구한 값을 별도로 저장해둔다.

현재 집의 최대 값은 거리1의 집의 값 혹은 거리2의 집의 값과 현재 집의 값을 더한 합 중 더 큰 값을 선택한다.

n 번째 집을 구하기 위해 n - 1 을 재귀호출해서 n 이 0보다 작은 경우까지 내려간다. 이때부터 값을 누적해서 dp 에 저장하기 때문에 동일한 n 의 값을 반복해서 재귀 호출할 필요 없다.

<br>

### Java

#### HouseRobber198

개선할 부분이 많은 코드이나 작성한 코드를 기준으로 설명한다.

바로 옆에 이웃한 집은 선택할 수 없어서 누적된 합에서 거리가 2 혹은 3인 집 중에서 누적합이 더 큰 집을 선택했다.

마지막에는 누적된 합을 구한 dp 배열에서 stream 으로 최대값을 구해서 리턴한다.

<br>

#### HouseRobber198_2

HouseRobber198 에서 아쉬운 부분들을 개선했다.

먼저, 거리가 2 혹은 3인 집 중에서 고르지 않고 거리가 1 혹은 2인 집 중에서 고를 수 있다. 

거리가 1 혹은 2인 집 중에서 고르게 되면 nums 의 길이에 따른 예외 처리하는 코드의 양이 줄어든다. 

HouseRobber198 에서는 for 문을 3부터 돌기 때문에 dp[0], dp[1], dp[2] 를 for 문을 돌기 전에 미리 구한다. 이 풀이에서는 for 문을 2부터 돌기 때문에 dp[0], dp[1] 만 for 문을 돌기 전에 미리 구한다.

거리가 1인 집은 바로 이웃한 집이라 선택할 수 없다고 앞에서 언급했는데 바로 이웃한 집을 선택하면 현재 집을 선택하지 않고 이웃한 집을 선택해야 한다.

다음으로, 최대값을 따로 구할 필요가 없고 dp 의 마지막 요소가 최대값이라 마지막 요소를 리턴하면 된다.

매번 최대값을 선택해가므로 마지막 요소가 최대값이다.

<br>

### Kotlin

#### HouseRobber198

다이나믹 프로그래밍 유형의 문제다. 

인접한 집을 연달아 선택할 수 없다고 해서 반드시 1칸씩만 건너 뛰어야 하는게 아니다. 예를 들어 nums 가 [100, 1, 1, 100] 면 200이 정답이다.

직전 dp 값과 두 칸 이전의 dp 값과 현재 값의 합 중에서 더 큰 값을 선택한다. 직전 dp 값은 현재 값과 더할 수 없기 때문에 갱신만 가능하다.

<br>

#### HouseRobber198_2

HouseRobber198 와 동일한 방식으로 풀이했고 보다 간결하게 작성했다.

배열의 크기가 2 혹은 그 이상일때 공통적으로 1번 인덱스를 구해줘야 하는 부분에 주의해야 한다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰
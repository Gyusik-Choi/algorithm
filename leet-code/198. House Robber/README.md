# LeetCode

## [198. House Robber](https://leetcode.com/problems/house-robber/)

다이나믹 프로그래밍 유형의 문제다.

타뷸레이션, 메모이제이션을 활용해서 풀이했다. 이 문제는 피보나치 수를 구하는 방식과 유사하게 접근할 수 있다.

<br>

### 타뷸레이션

교재는 상향식 풀이를 타뷸레이션으로 정의한다. for 문을 이용해서 작은 수의 결과를 구하고 이 결과를 활용해서 보다 큰 수의 결과를 구하면서 n 의 값을 구한다.

거리 2의 집의 값에서 현재 집의 값을 합과 거리 1의 집의 값 중 큰 값을 현재 집의 값으로 한다. 거리1의 값은 현재 집의 값과 맞닿아 있는 집이라 현재 집의 값과 더하지 않는다. 이 방식으로 현재 집의 최대 값을 누적해나갈 수 있다. 현재 집에서는 거리1의 집의 값을 가져올 수 있으나 현재 집과 더하지만 않으면 된다. 거리1의 집은 현재 집의 다음 집에서 거리1의 집과 더한 합을 현재 집의 값과 비교할 수 있다.

<br>

### 메모이제이션

재귀를 활용해서 풀이하되 동일한 값을 반복해서 구하지 않기 위해 한번 구한 값을 별도로 저장해둔다.

현재 집의 최대 값은 거리1의 집의 값 혹은 거리2의 집의 값과 현재 집의 값을 더한 합 중 더 큰 값을 선택한다.

n 번째 집을 구하기 위해 n - 1 을 재귀호출해서 n 이 0보다 작은 경우까지 내려간다. 이때부터 값을 누적해서 dp 에 저장하기 때문에 동일한 n 의 값을 반복해서 재귀 호출할 필요 없다.

<br>

<참고>

파이썬 알고리즘 인터뷰


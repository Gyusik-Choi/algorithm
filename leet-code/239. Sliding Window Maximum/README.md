# LeetCode

## [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

### Python

어려운 문제였다.

교재의 풀이도 시간 초과가 나서 다른 분들의 풀이를 참고해서 풀이했다.

<br>

#### 첫번째 풀이

큐에는 최대값만 유지하면서 매번 k개에서 최대값을 구하는 연산을 하지 않도록 했다. 큐에 있는 값이 k 윈도우 범위를 벗어날 경우는 큐에서 제거했다. 큐에 값이 아닌 인덱스를 넣어서 k 윈도우 범위를 벗어났는지를 인덱스 차이로 알 수 있었다.

풀이는 크게 두개의 for 문으로 나뉜다. 처음에는 큐에 값이 없기 때문에 k 윈도우 만큼의 초기값이 필요하다. 그 이후 부터는 큐에 매번 하나씩 넣고 최대값을 찾는 과정을 반복하게 된다.

첫번째 for 문은 k만큼 순회하면서 리스트 맨 앞의 k 윈도우 크기에서 최대값을 찾는다.

두번째 for 문은 k부터 nums 의 길이까지 순회하면서 k 윈도우 크기를 벗어난 요소가 큐에 있는지 검사하고 매번 최대값을 구한다.

<br>

#### 두번째 풀이

첫번째 풀이의 반복을 개선하고 싶었다. 

첫번째 for 문과 두번째 for 문에 반복이 존재한다. 큐에 최대값 하나만 유지하기 위해 for 문의 현재 요소가 큐에 있는 값보다 더 큰 값이면 큐에 있는 값을 빼고 for 문의 현재 요소를 넣는 과정과 최대값을 answer 리스트에 넣는 과정이 두 for 문에서 반복된다.

이를 개선하기 위해 교재의 풀이에서 쓰였던 방법을 활용했다. 교재는 일단 큐에 먼저 값을 넣고서 초기 k 윈도우 크기의 값을 확보하기 위해 첫 k - 1 범위까지는 최대값을 찾는 로직을 수행하지 않도록 if 조건을 걸었다.

이 풀이는 큐에 무조건 넣지 않고 최대값만 비교해서 넣기 때문에 큐에 넣는 작업은 첫 k 범위와 관계 없이 수행하면 되고 최대값을 구하는 부분만 피하면 된다. k 윈도우 만큼의 범위에서 최대값을 구할 수 있도록 if 조건을 통해 현재 for 문의 인덱스가 k - 1 보다 작은 경우 최대값을 구하지 않고 넘어간다.

<br>

### Java

#### SlidingWindowMaximum239

교재의 풀이를 참고했다.

원래 제출한 풀이는 시간초과가 발생했고 교재의 풀이를 참고해서 이 문제에 대한 접근방식을 바꿀 수 있었다. 시간초과가 발생한 풀이는 [10000, 9999, 9998, ... 2, 1] 처럼 내림차순으로 정렬된 배열의 경우 매번 덱의 모든 요소에서 최대값을 찾는 과정을 반복하면서 시간초과가 발생했다.

이 풀이는 덱의 맨 앞에 최대값을 유지한다. 새로 들어올 요소보다 작은 덱의 요소들은 뒤에서부터 매번 제거한다. 새로 들어올 요소가 기존 덱의 요소보다 작으면 덱의 요소를 제거하지 않기 때문에 최대값 하나만 덱에 항상 유지되는 것은 아니다. 

덱에 k 범위를 유지하지 않고 가능한 최대값만 남기기 때문에 내림차순 배열이 nums 로 주어지더라도 매번 k 크기만큼 비교하지 않아도 된다.

<br>

####SlidingWindowMaximum239_2

우선순위 큐를 사용해서 풀이했다. 우선순위 큐에는 값과 인덱스를 갖는 객체를 넣는다. 

우선순위 큐의 최상단에 있는 값이 슬라이딩 윈도우 범위를 벗어나지 않으면 우선순위 큐의 최상단 값을 유지한다. 슬라이딩 윈도우 범위를 벗어나면 범위 내의 요소가 나타날 때까지 우선순위 큐를 비운다.

<br>

### Kotlin

#### SlidingWindowMaximum239

교재의 풀이를 참고했다.

덱의 맨 앞에 최대값을 둔다. 슬라이딩 윈도우 크기를 벗어난 덱의 요소는 제거하고 새로 덱에 넣을 요소보다 작은 덱의 요소는 뒤에서부터 제거한다.

덱에 요소를 넣을 때는 뒤에서 부터 넣기 때문에 기존 요소와 새로 넣을 요소를 비교할 때는 덱의 뒤에서부터 비교한다. 앞에서부터 비교하면 슬라이딩 윈도우 크기 내의 최대값을 제대로 찾지 못할 수 있다.

예를 들어, 현재 덱에 [9, 6, 3] 이 있다고 할 때 슬라이딩 윈도우 크기는 3이고 5를 새로 넣는다고 가정해보겠다. 덱의 맨 앞부터 비교하면 9의 경우 5가 추가되면 슬라이딩 윈도우 크기를 벗어나서 제거된다. 6은 5보다 크기 때문에 [6, 3, 5] 가 들어온다. 반면에 덱의 맨 뒤부터 비교하면 [6, 5] 가 되면서 3이 제거되고 5가 덱에 들어온다. 

<br>

<참고>

파이썬 알고리즘 인터뷰

https://velog.io/@ilov1112/Leetcode-239.-Sliding-Window-Maximum

자바 알고리즘 인터뷰


# LeetCode

## [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

어려운 문제였다.

교재의 풀이도 시간 초과가 나서 다른 분들의 풀이를 참고해서 풀이했다.

<br>

### 첫번째 풀이

큐에는 최대값만 유지하면서 매번 k개에서 최대값을 구하는 연산을 하지 않도록 했다. 큐에 있는 값이 k 윈도우 범위를 벗어날 경우는 큐에서 제거했다. 큐에 값이 아닌 인덱스를 넣어서 k 윈도우 범위를 벗어났는지를 인덱스 차이로 알 수 있었다.

풀이는 크게 두개의 for 문으로 나뉜다. 처음에는 큐에 값이 없기 때문에 k 윈도우 만큼의 초기값이 필요하다. 그 이후 부터는 큐에 매번 하나씩 넣고 최대값을 찾는 과정을 반복하게 된다.

첫번째 for 문은 k만큼 순회하면서 리스트 맨 앞의 k 윈도우 크기에서 최대값을 찾는다.

두번째 for 문은 k부터 nums 의 길이까지 순회하면서 k 윈도우 크기를 벗어난 요소가 큐에 있는지 검사하고 매번 최대값을 구한다.

<br>

### 두번째 풀이

첫번째 풀이의 반복을 개선하고 싶었다. 

첫번째 for 문과 두번째 for 문에 반복이 존재한다. 큐에 최대값 하나만 유지하기 위해 for 문의 현재 요소가 큐에 있는 값보다 더 큰 값이면 큐에 있는 값을 빼고 for 문의 현재 요소를 넣는 과정과 최대값을 answer 리스트에 넣는 과정이 두 for 문에서 반복된다.

이를 개선하기 위해 교재의 풀이에서 쓰였던 방법을 활용했다. 교재는 일단 큐에 먼저 값을 넣고서 초기 k 윈도우 크기의 값을 확보하기 위해 첫 k - 1 범위까지는 최대값을 찾는 로직을 수행하지 않도록 if 조건을 걸었다.

이 풀이는 큐에 무조건 넣지 않고 최대값만 비교해서 넣기 때문에 큐에 넣는 작업은 첫 k 범위와 관계 없이 수행하면 되고 최대값을 구하는 부분만 피하면 된다. k 윈도우 만큼의 범위에서 최대값을 구할 수 있도록 if 조건을 통해 현재 for 문의 인덱스가 k - 1 보다 작은 경우 최대값을 구하지 않고 넘어간다.

<br>

<참고>

파이썬 알고리즘 인터뷰

https://velog.io/@ilov1112/Leetcode-239.-Sliding-Window-Maximum


# LeetCode

## [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

### Python

정렬을 활용해서 풀이했다.

첫번째 풀이는 0번 인덱스 값을 시작 값인 cur 로 두고, 1번 인덱스부터 for 문을 돌면서 for 문의 요소인 next 를 cur 과 비교하는 방법을 사용한다.

cur 의 1번 인덱스 값이 next 의 0번 인덱스 값 보다 크거나 같으면 겹치는 경우다. 이때 cur 의 1번 인덱스 값과 next 의 1번 인덱스 값을 비교해서 둘 중 더 큰 값으로 cur 를 갱신한다.

cur 의 1번 인덱스 값이 next 의 0번 인덱스 값 보다 작은 경우 cur 을 answer 리스트에 넣는다.

for 문의 마지막 next 와 cur 을 비교한 후 cur 는 answer 에 들어가지 못했다. if 문에서는 cur 가 갱신되고 else 문에서는 기존의 cur 가 들어가고 기존의 cur 는 next 로 대치되면서 새로운 cur 가 된다. 결국 cur 는 answer 에 들어가지 못했다.

for 문을 마친후 cur 를 answer 에 넣어준다.

<br>

두번째 풀이는 교재의 풀이를 참고했다. 두번째 풀이가 훨씬 간결하다.

첫번째 풀이와 달리 cur 같은 변수를 사용하지 않고 for 문을 마친 후 별도로 요소를 넣지 않는다. for 문 안에서 비교와 정답이 완성된다.

정답을 담는 배열인 merged_lst 가 비었다면 for 문을 요소 item 을 우선 넣는다. 혹은 merged_lst 가 비어있지 않더라도 겹치지 않으면 현재 요소를 배열에 넣는다.

겹치는 경우 (merged_lst 가 비어있지 않고 merged_lst 의 마지막 요소의 1번 인덱스 값이 item 의 0번 인덱스 값보다 크거나 같으면 ) merged_lst 의 마지막 요소를 갱신한다.

for 문 안에서 리스트에 있는 요소를 갱신하거나 마지막 요소를 리스트에 넣는 작업이 이루어지기 때문에 첫번째 풀이와 달리 마지막 요소를 for 문 이후에 넣어줄 필요가 없다.

<br>

### Java

#### MergeIntervals56

병합정렬을 구현해서 풀이했다. intervals 를 정렬한 후 스택을 이용해서 배열간에 겹치는 부분이 있는지 확인했다.

정렬한 intervals 의 첫번째 요소를 스택에 넣고, 두번째 인덱스부터 for 문을 돌면서 스택에서 꺼낸 요소와 비교한다.

스택에서 꺼낸 요소의 두번째 인덱스가 for 문의 요소인 배열의 첫번째 인덱스보다 크거나 같다면 구간이 겹치는 경우다. 이때 스택에는 겹치는 구간을 합친 하나의 배열을 스택에 넣는다. 스택에서 꺼낸 요소의 첫번째 인덱스를 배열의 첫번째 인덱스에 넣고, 스택에서 꺼낸 요소의 두번째 인덱스와 for 문의 요소의 두번째 인덱스 중에 더 큰 값을 넣는다.

스택에서 꺼낸 요소의 두번째 인덱스가 for 문의 요소인 배열의 첫번째 인덱스보다 작다면 구간이 겹치지 않아서 스택에서 꺼낸 요소를 다시 스택에 넣고, for 문의 요소도 스택에 넣는다.

<br>

#### MergeIntervals56_2

교재의 풀이를 참고했다. 

교재는 내장 정렬 함수를 이용해서 정렬했고, 스택 대신 리스트를 사용해서 풀이했다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


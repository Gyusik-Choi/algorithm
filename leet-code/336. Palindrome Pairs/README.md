# LeetCode

## [336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/)

### Java

매우 어려운 문제였다. 교재의 풀이를 참고했다.

<br>

### 팰린드롬 경우의 수

1) 두 단어의 길이가 같은 경우

2) 두 단어 중 비교하는 단어가 비교 대상 단어보다 짧은 경우

3) 두 단어 중 비교하는 단어가 비교 대상 단어보다 긴 경우

<br>

#### 두 단어의 길이가 같은 경우

두 단어의 길이가 같고 하나를 뒤집어서 비교했을 경우 다른 하나와 같다. 이 경우 두 단어를 더하지 않더라도 일종의 데칼코마니처럼 하나를 뒤집어서 비교하면 동일하다.

<br>

#### 두 단어 중 비교하는 단어가 비교 대상 단어보다 짧은 경우

비교 대상 단어 보다 더 짧은 경우 자신의 길이만큼 트라이를 끝까지 비교한 후 남은 단어의 문자열이 팰린드롬이면 두 단어는 합쳐서 팰린드롬인 경우를 충족한다. 끝까지 비교를 할 수 있다는 것은 뒤집어서 비교한 문자가 지금까지 모두 같았다는 의미다.

<br>

#### 두 단어 중 비교하는 단어가 비교 대상 단어보다 긴 경우

비교 대상 단어 보다 더 긴 경우 비교하는 중간에 글자가 끝난 단어가 있고, 남은 문자열이 팰린드롬인 경우 두 단어는 합쳐서 팰린드롬인 경우를 충족한다. 

<br>

### Kotlin

#### PalindromePairs336

어려운 문제였다. Leetcode 제출시 1개의 케이스가 시간 초과 및 메모리 초과가 발생했다. 

시간 초과의 경우 팰린드롬을 검증하는 로직을 기존에는 대상 문자열과 대상 문자열을 뒤집은 값이 동일한지 판단하는 방법에서 시작과 끝 인덱스를 두고 인덱스를 좁혀나가는 투 포인터 방식으로 비교하는 방법으로 바꾸면서 개선됐다. 

그러나 메모리 초과는 어떻게 개선해야할지 잘 찾지를 못했는데 교재의 풀이에서 힌트를 얻을 수 있었다. 기존 풀이는 문자열을 뒤집은 트라이를 관리하는 reversedTrie 외에 기존 문자열에 대한 트라이를 관리하는 trie 도 두고 있었다. 그런데 정작 trie 는 거의 사용하지 않았고 불필요한 메모리를 많이 점유했던게 메모리 초과의 원인이 됐다. 그래서 trie 를 제거하고 reversedTrie 만 사용하는 코드로 변경하면서 통과할 수 있었다.

<br>

<참고>

자바 알고리즘 인터뷰


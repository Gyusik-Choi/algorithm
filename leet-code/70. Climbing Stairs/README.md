# LeetCode

## [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)

### Python

다이나믹 프로그래밍 유형의 문제다. 메모이제이션, 타뷸레이션 모두 가능하다.

메모이제이션의 경우 재귀로만 풀 경우 시간 초과가 발생했다. 타뷸레이션은 for 문을 사용해서 풀이했다.

<br>

이 문제는 피보나치 수열과 상당히 유사하다. 피보나치 수열과 차이는 피보나치 수열에서 2는 1인데 이 문제에서는 2다.

n이 5라면 4와 3으로 나눠질 수 있다. 4와 3은 각각 3과 2, 2와 1로 나눠질 수 있다. 1을 제외하고는 모두 2갈래로 나눠진다. 5는 4와 3의 결과를 합한 값이다. 즉, n 은 n - 1, n - 2 의 합으로 구해진다.

<br>

### Java

#### ClimbingStairs70

다이나믹 프로그래밍 유형의 문제로 피보나치 수열과 유사한 방식으로 풀이했다.

n 은 n - 1, n - 2 의 합으로 구한다. for 문을 사용해도 가능한데 이 풀이에서는 메모이제이션과 재귀를 활용했다.

계단을 오를 때 한번에 1칸 혹은 2칸씩 오를 수 있다. 현재 계단에 1칸 이전과 2칸 이전의 계단에서 현재 계단으로 올 수 있다. 

1칸 이전의 계단에서는 1칸을 오르고, 2칸 이전의 계단에서는 2칸을 오르면 현재 계단에 도착할 수 있다. 1칸 이전과 2칸 이전 계단은 각각 1칸과 2칸을 선택한다. 현재 계단에 오를 수 있는 방법은 1칸 이전 계단에 오를 수 있는 방법과 2칸 이전 계단에 오를 수 있는 방법의 합으로 구할 수 있다.

2칸 이전의 계단에서 1칸씩 2번을 오르는 방법도 있다고 생각할 수 있으나 이러면 중복이 발생한다.

```
4칸에 오르는 방법
1) 1 + 1 + 2
2) 2 + 2
3) 1 + 1 + 1 + 1
4) 1 + 2 + 1
5) 2 + 1 + 1

1)과 2)가 2칸 이전의 계단에서 2칸을 올라서 4칸이 되는 방법이다. 
1)은 기존에 1 + 1, 2)는 기존에 2고 여기서 2를 더한다. 
만약에 2를 더하지 않고 1 + 1 을 더하면 1)과 2)는 각각 3)과 5)와 중복된다.
```

<br>

<참고>

파이썬 알고리즘 인터뷰


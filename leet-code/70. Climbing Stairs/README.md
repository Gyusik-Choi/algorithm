# LeetCode

## [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)

### Python

다이나믹 프로그래밍 유형의 문제다. 메모이제이션, 타뷸레이션 모두 가능하다.

메모이제이션의 경우 재귀로만 풀 경우 시간 초과가 발생했다. 타뷸레이션은 for 문을 사용해서 풀이했다.

<br>

이 문제는 피보나치 수열과 상당히 유사하다. 피보나치 수열과 차이는 피보나치 수열에서 2는 1인데 이 문제에서는 2다.

n이 5라면 4와 3으로 나눠질 수 있다. 4와 3은 각각 3과 2, 2와 1로 나눠질 수 있다. 1을 제외하고는 모두 2갈래로 나눠진다. 5는 4와 3의 결과를 합한 값이다. 즉, n 은 n - 1, n - 2 의 합으로 구해진다.

<br>

### Java

#### ClimbingStairs70

다이나믹 프로그래밍 유형의 문제로 피보나치 수열과 유사한 방식으로 풀이했다.

n 은 n - 1, n - 2 의 합으로 구한다. for 문을 사용해도 가능한데 이 풀이에서는 메모이제이션과 재귀를 활용했다.

계단을 오를 때 한번에 1칸 혹은 2칸씩 오를 수 있다. 현재 계단에 1칸 이전과 2칸 이전의 계단에서 현재 계단으로 올 수 있다. 

1칸 이전의 계단에서는 1칸을 오르고, 2칸 이전의 계단에서는 2칸을 오르면 현재 계단에 도착할 수 있다. 1칸 이전과 2칸 이전 계단은 각각 1칸과 2칸을 선택한다. 현재 계단에 오를 수 있는 방법은 1칸 이전 계단에 오를 수 있는 방법과 2칸 이전 계단에 오를 수 있는 방법의 합으로 구할 수 있다.

2칸 이전의 계단에서 1칸씩 2번을 오르는 방법도 있다고 생각할 수 있으나 이러면 중복이 발생한다.

```
4칸에 오르는 방법
1) 1 + 1 + 2
2) 2 + 2
3) 1 + 1 + 1 + 1
4) 1 + 2 + 1
5) 2 + 1 + 1

1)과 2)가 2칸 이전의 계단에서 2칸을 올라서 4칸이 되는 방법이다. 
1)은 기존에 1 + 1, 2)는 기존에 2고 여기서 2를 더한다. 
만약에 2를 더하지 않고 1 + 1 을 더하면 1)과 2)는 각각 3)과 5)와 중복된다.
```

<br>

### Kotlin

#### ClimbingStairs70

다이나믹 프로그래밍 유형의 문제다. 피보나치 수열을 구하는 것과 거의 동일한 방식으로 풀이할 수 있다.

계단은 1칸 혹은 2칸씩 오를 수 있다. 현재 칸은 1칸 아래와 2칸 아래의 계단을 오를 수 있는 방법의 합계와 같다.

피보나치 수열과 다른 점은 0번의 값이 피보나치 수열이 0인 반면 여기서는 1이다.

타뷸레이션 방식(자바 알고리즘 인터뷰 p. 811) 으로 0번, 1번 값을 초기화 한후 2부터 n까지 올라가면서 풀이했다.

<br>

#### ClimbingStairs70_2

재귀와 메모이제이션 방식으로 풀이했다. 피보나치 수열을 구하는 방식과 거의 동일하다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


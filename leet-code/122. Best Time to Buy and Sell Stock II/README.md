# LeetCode

## [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)

### Python

그리디 유형의 문제다.

이전 가격 보다 더 높은 가격이 나오면 즉시 팔고, 직전 가격 보다 더 낮은 가격이 나오면 즉시 산다.

당일에 사서 당일에 바로 팔 수 있어서 사는건 생각하지 않아도 된다. 직전 가격 보다 현재 가격이 더 낮으면 직전 가격을 팔고 현재 가격을 샀다고 가정할 수 있다. 현재 가격이 더 높은지 찾아서 파는 것만 생각하면 된다.

가장 높은 가격이 나올 때 까지 기다리지 않아도 된다. 예를 들어 prices 로 1, 3, 5가 나왔다고 하면 1에 사서 3에 팔고, 다시 3을 사서 5에 파는 것과 1에 사서 5에 파는 것의 이익은 동일하다. 높은 가격이 나오면 즉시 팔면 된다. 

물론 문제에서 당일에 사서 당일에 파는건 가능하다고 했으나, 당일에 팔고 당일에 사는게 가능하다고 언급하지는 않았다. 그러나 위의 예시에서 보듯이 계속 주식이 상승하는 경우 당일에 팔고 당일에 다시 사는 방법을 취해도 이익은 동일하다.

또한 주식이 계속 상승하는 경우가 아니면 더더욱 가장 높은 가격이 나올 때 까지 기다리지 않고 높은 가격이 나오면 즉시 파는게 더 높은 이익을 얻을 수도 있다. 예를 들어 prices 가 1, 3, 2, 6이 나왔다고 하면 1에 사서 6에 파는 것 보다 1에 사서 3에 팔고, 2에 사서 6에 파는게 더 큰 이익을 얻을 수 있다.

<br>

첫번째 풀이에서는 여러 조건들을 고려했는데, 교재의 풀이를 참고해서 이후 풀이부터 고려할 조건을 간소화하고 코드를 줄일 수 있었다.

첫번째 풀이에서는 사는 것과 파는 것을 모두 고려하면서 코드가 다른 풀이보다 상대적으로 조건이 많다.

<br>

### Java

그리디 유형의 문제다.

최대 이익을 내기 위해 현재 가격에 집중한다. 직전 가격보다 현재 가격이 더 낮으면 직전 가격을 현재 가격으로 대체하고, 직전 가격보다 현재 가격이 더 높으면 현재 가격에서 직전 가격을 뺀 값을 누적한다.

더 싼 가격이 나오면 더 싼 가격으로 주식을 대체하고, 더 비싼 가격이 나오면 즉시 팔아서 번 값을 누적한다.

<br>

### Kotlin

그리디 알고리즘을 활용했다.

오늘 사서 오늘 바로 팔 수도 있기 때문에 내일 가격이 오늘보다 낮으면 오늘 바로 판다. 만약에 내일 가격이 오늘 가격보다 더 비싸면 내일 바로 판다.

1, 3, 5 처럼 매일 가격이 오르는 경우 1에 사서 3에 팔지 않고 5에 파는 이익과 1에 사서 3에 팔고 3을 사서 5에 파는것과 같다. 가격이 다음날 오르면 바로 팔고 다음날 가격이 내리면 오늘 바로 판다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰
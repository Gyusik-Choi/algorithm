# LeetCode

## 687. Longest Univalue Path

### Python

재귀호출로 리턴하는 값은 left, right 중에서 더 큰 값이다. 하나의 트리 줄기를 left, right 의 값으로 가져간다. 그 과정에서 동일한 값을 갖는 가장 긴 경로를 찾기 위해 부모 노드와 자식 노드의 val 값을 비교한다.

부모 노드의 val 과 왼쪽 자식 노드의 val 이 같으면 left 의 값을 1 증가시키고, 그렇지 않으면 left 를 0으로 초기화한다. 부모 노드의 val 과 오른쪽 자식 노드의 val 이 같으면 right 의 값을 1 증가시키고, 그렇지 않으면 right 를 0으로 초기화한다.

가장 긴 경로를 구하기 위해 longest 와 left + right 중에서 더 큰 값으로 longest 를 갱신한다.

<br>

위에서 "하나의 줄기를 left, right 의 값으로 가져간다" 고 얘기했는데 이와 관련해서 교재에서는 아래와 같이 설명하고 있다. 하나의 줄기를 가져가는가는 방식인 것은 알겠는데 왜 그런건지 잘 이해가 안 됐는데 교재의 설명이 이를 이해하는데 도움이 됐다.

```
지금까지 합의 최대값을 계산해왔기 때문에 따라서 상태값도 합인 left + right 를 리턴해야 할 것 같다. 그러나 잠시 생각해보면, 현재 노드는 양쪽 자식 노드를 모두 연결할 수 있지만 현재 노드의 부모 노드에서는 지금의 양쪽 자식 노드를 동시에 연결할 수 없다. 단방향이므로 양쪽 자식 노드 중 어느 한쪽 자식만 택할 수 있으며, 이는 트리의 특징이기도 하다. 따라서 둘 중 큰 값을 상태값으로 리턴해준다. 어차피 한 군데만 방문할 수 있다면 더 큰 쪽을 방문하는 게 낫기 때문이다.
```

<br>

교재에서 말하는 상태값은 재귀 호출을 호출한 부분에서 left 혹은 right 로 받게되는 값이다. 현재 노드의 부모 노드는 현재 노드의 자식 노드 2개 중 하나만 선택할 수 있어서 left + right 를 리턴하지 않고 둘 중 더 큰 값 하나만 리턴한다.

<br>

### Java

#### LongestUnivaluePath687

재귀를 활용했다.

최대값을 구하는 부분과 재귀 호출의 리턴값을 구하는 부분을 분리해서 생각해야 한다. 최대값을 구하는 현재 노드는 양쪽 자식 노드와 합칠 수 있으나, 현재 노드의 재귀 호출 리턴값을 받을 부모 노드는 양쪽 자식 노드와 합칠 수 없고 하나의 노드만 선택할 수 있다.

최대값은 양쪽 자식노드와 더하는 반면에 재귀 호출의 리턴값은 자신을 호출한 부모 노드로 올라가기 때문에 양쪽 자식노드 중 더 큰 값을 리턴한다.

<br>

#### LongestUnivaluePath687_2

LongestUnivaluePath687 과 전체적인 방법은 동일하지만 일부 다른 부분들이 있다. LongestUnivaluePath687_2 에서는 정점이 아닌 간선에 초점을 맞춰서 길이를 갱신했다.

먼저, 최대값을 1이 아닌 0으로 초기화하고 리턴할때 1을 빼지 않는다.

다음으로 현재 노드가 왼쪽, 오른쪽 자식 노드와 모두 같을 때 왼쪽 자식노드의 재귀호출 값(변수 left)과 오른쪽 자식노드의 재귀호출 값(변수 right)에 2를 더한다.

그리고 자식 노드와 모두 다를 때 1이 아닌 0을 리턴한다.

<br>

LongestUnivaluePath687 에서 최대값을 1로 갱신하고 마지막에 1을 빼는 부분이 아쉬웠다. 0으로 초기화하고 구한 최대값을 그대로 리턴하고 싶었다. 이에 맞춰서 연관된 부분들을 수정하게 됐다.

현재 노드가 양쪽 자식노드와 같을 때 left 와 right 에서 2를 더하는 이유는 2개의 간선이 추가되기 때문이다. 교재의 풀이는 현재 노드가 양쪽 자식노드와 같을 때를 따로 판단하지 않고 왼쪽 노드와 같으면 left 를 1 더하고, 오른쪽 노드와 같으면 right 를 1 더하는 방법으로 하기 때문에 결국 현재 노드가 양쪽 자식 노드와 같으면 left + right + 2 가 된다.

반면에 현재 노드와 양쪽 자식 노드가 모두 다를 때는 연결할 간선이 없어서 0을 리턴한다.

<br>

#### LongestUnivaluePath687_3

교재의 풀이를 참고했다.

<br>

### Kotlin

#### LongestUnivaluePath687

재귀를 활용했다.

왼쪽, 오른쪽 자식 노드를 재귀호출 하면서 노드가 null 이거나 양쪽 자식노드와 부모 노드가 일치하는 값이 없을 경우 0을 리턴한다. 문제에서는 정점이 아닌 간선의 갯수를 요구했기 때문에 1이 아닌 0을 리턴했다.

이 외에 3가지 경우의 수를 나눠서 진행했다. 

왼쪽, 오른쪽 자식노드의 값과 부모노드의 값이 모두 같은 경우 왼쪽과 오른쪽 자식노드가 부모 노드로 합쳐지면서 간선이 2개가 늘어난다. 최대 길이는 기존 최대 길이에 왼쪽 자식노드를 재귀호출한 값과 오른쪽 자식노드를 재귀호출한 값에 2를 더한 값과 비교했다. 리턴하는 값은 부모노드와 합쳐질 왼쪽, 오른쪽 자식노드의 간선 중 하나를 골라야 한다. 최대 길이와 달리 왼쪽, 오른쪽 자식노드를 재귀호출한 값 중 더 큰 값에 1을 더한 값을 리턴 값으로 한다. 

왼쪽 자식노드와 오른쪽 자식노드의 값이 다르고 부모노드의 값이 왼쪽 자식노드의 값과 같은 경우 최대 길이는 기존 최대 길이와 왼쪽 자식노드를 재귀호출한 값에 1을 더한 값을 비교한다.

왼쪽 자식노드와 오른쪽 자식노드의 값이 다르고 부모노드의 값이 오른쪽 자식노드의 값과 같은 경우 최대 길이는 기존 최대 길이와 오른쪽 자식노드를 재귀호출한 값에 1을 더한 값을 비교한다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


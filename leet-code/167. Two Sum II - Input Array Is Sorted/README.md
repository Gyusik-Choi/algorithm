# LeetCode

## [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

### Python

#### 첫번째 풀이

투포인터를 활용했다. 

리스트가 정렬되어 있어서 리스트의 시작점과 끝점에 포인터를 하나씩 두고 두 포인터의 값을 더해서 target 과 같은지 비교한다.

두 포인터가 같아지기 전까지 계속 비교하면서 두 포인터의 값이 target 과 같으면 두 포인터의 인덱스를 각각 1씩 더한 값(이 문제에서 첫번째 인덱스는 0이 아니라 1을 의미한다)을 리턴한다. 

두 포인터의 값이 target 보다 작으면 더 큰 값을 구하기 위해 왼쪽 포인터를 우측으로 한칸 이동한다. 

두 포인터의 값이 target 보다 크면 더 작은 값을 구하기 위해 오른쪽 포인터를 왼쪽으로 한칸 이동한다.

n 번의 탐색을 수행하면 돼서 시간 복잡도는 O(N) 이다.

<br>

#### 두번째 풀이

이진탐색을 활용한다.

n 개의 요소에 대해 O(logN) 시간 복잡도의 이진탐색을 수행해서 전체 시간복잡도는 O(NlogN) 이 된다. 

for 문을 돌면서 for 문의 요소와 더해서 target 을 만들 수 있는 숫자를 이진탐색으로 찾는다.

이때 주의할 점은 numbers 가 [1, 2, 3, 4, 4, 9, 56, 90], target 이 8인 경우 4, 4 와 같은 답이 나오면 안 된다.

동일한 인덱스를 찾지 않도록 아예 탐색 범위를 좁혀서 for 문의 요소 다음 인덱스부터 찾도록 이진탐색을 해야 한다.

<br>

#### 세번째 풀이

bisect 모듈의 bisect_left 함수를 활용했다.

bisect_left 함수는 대상 리스트, 대상 숫자 외에 시작점과 끝점에 대한 범위를 인자로 넣을 수 있다.

교재의 풀이를 참고해서 끝점을 제외하고 대상 리스트, 대상 숫자, 시작점을 인자로 넣어서 풀이했다.

bisect_left 함수는 소스코드에서 끝점을 인자로 넣지 않으면 디폴트로 우측 끝 범위를 리스트 길이로 정한다. 만약 찾는 숫자가 없어서 인덱스가 우측으로 벗어날 경우 리스트 길이가 반환돼서 해당 값으로 인덱스 접근시 인덱스 에러가 발생할 수 있다. 이 에러를 막기 위해 조건문으로 리스트의 인덱스를 넘어갔는지 확인한다.

<br>

### Java

#### TwoSumInputArrayIsSorted167

투포인터를 활용해서 풀이했다.

배열의 양 끝에 포인터를 하나씩 두고 각 포인터가 가리키는 값의 합이 target 보다 작으면 더 큰 합을 만들기 위해 left 를 우측으로 이동하고, target 보다 크면 더 작은 합을 만들기 위해 right 를 좌측으로 이동한다.

<br>

#### TwoSumInputArrayIsSorted167_2

이진탐색을 활용해서 풀이했다.

배열을 for 문으로 순회하면서 요소의 뒷 부분에 해당하는 구간을 이진탐색한다. target 에서 for 문의 요소를 뺀 값이 존재하는지 배열에서 이진탐색으로 조회한다.

<br>

### Kotlin

#### TwoSumInputArrayIsSorted167

투포인터를 활용했다.

한 요소를 중복해서 사용하면 안되기 때문에 배열의 양 끝에 포인터 변수를 하나씩 두고 왼쪽이 오른쪽 보다 작은 경우 탐색을 이어나간다. 

배열이 오름차순으로 정렬되어 있어서 두 포인터가 가리키는 요소의 합을 더 크게 만드려면 왼쪽 포인터를 오른쪽으로 이동하고 두 포인터가 가리키는 요소의 합을 더 작게 만드려면 오른쪽 포인터를 왼쪽으로 이동한다.

두 포인터가 가리키는 요소의 합이 target 과 같으면 정답이다. 두 포인터가 가리키는 요소의 합이 target 보다 작으면 더 큰 합을 만들기 위해 왼쪽의 요소를 오른쪽으로 이동한다. 두 포인터가 가리키는 요소의 합이 target 보다 크면 더 작은 합을 만들기 위해 오른쪽의 요소를 왼쪽으로 이동한다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


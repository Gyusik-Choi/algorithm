# LeetCode

## [406. Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/)

### Python

어려운 문제였다. 

그리디 유형의 문제로 교재의 풀이를 참고했다.

그리디 방식으로 풀이할 수 있겠다는 부분까지는 접근했지만 구체적인 풀이방법은 잘 떠오르지 않았다.

<br>

조건(혹은 우선순위)에 맞춰서 people 을 정렬한 후 정렬된 people 을 순서대로 answer 에 담으면 된다. 

people 의 정렬 조건은 키는 내림차순, 자신보다 키가 큰 사람의 수는 오름차순이다.

peope 을 answer 에 담을 때 조건에 맞춰 정렬 했다면 다음 요소는 고려하지 않고 현재 요소를 기준에 맞춰서 answer 에 담으면 되기 때문에 그리디하게 풀이할 수 있다.

answer 에 people 을 담을때 people 의 요소 중 '자신보다 키가 큰 사람의 수'를 answer 에 넣을 인덱스로 사용한다. 문제에서 큐를 재구성할 수 있는 people 만 주어진다고 했기 때문에 인덱스가 벗어날 우려는 하지 않아도 된다.

people 을 키는 내림차순으로 정렬했기 때문에 자신보다 키가 큰 사람의 수가 같더라도 키가 큰 요소가 앞에 온다. 그래서 키가 큰 요소가 먼저 인덱스에 맞춰 들어간 후 키가 작은 요소가 기존의 키가 큰 요소의 인덱스에 들어오고 키가 큰 요소는 다음 인덱스로 밀려나면서 조건에 맞는 answer 가 구성될 수 있다.

<br>

교재에서는 우선순위 큐를 사용했는데 이 풀이에서는 정렬을 사용했다. people 요소가 추가되지 않아서 한번만 정렬하면 그대로 활용할 수 있으므로 우선순위 큐 대신 정렬로 풀이했다.

<br>

### Java

교재의 풀이를 참고하여 우선순위 큐를 활용해서 풀이했다.

<br>

### Kotlin

#### QueueReconstructionByHeight406

우선순위 큐를 활용했다.

이 풀이는 교재의 풀이보다 다소 비효율적인 부분이 있다.

교재의 풀이는 우선순위에서 꺼내는 요소를 곧장 정답을 담는 리스트에 넣을 수 있지만 이 풀이는 그렇지 못한다. 우선순위 큐에서 꺼낸 뒤 해당하는 순서의 요소가 아니면 다시 우선순위 큐로 넣으면서 올바른 순서의 요소가 나올 때까지 반복한다.

우선순위 큐의 정렬 기준을 0번 인덱스인 키를 기준으로 오름차순으로 하되 키가 같을 경우 배열의 1번 인덱스인 자신보다 키가 크거나 같은 사람이 몇 명 있는지 나타내는 값을 오름차순으로 한다.

키가 작은 순서대로 우선순위 큐에서 나오긴 하지만 자신보다 키가 크거나 같은 사람이 있는 인원이 맞지 않으면 다시 우선순위 큐로 돌아간다.

<br>

#### QueueReconstructionByHeight406_2

교재의 풀이를 참고해서 풀이했다.

QueueReconstructionByHeight406 풀이에서 나타난 우선순위 큐에서 꺼낸뒤 다시 우선순위 큐에 들어가는 비효율성을 개선했다.

우선순위 큐의 정렬 기준을 변경해서 비효율성을 개선할 수 있었다. 우선순위 큐의 정렬 기준을 키를 내림차순으로 하되 키가 같은 경우 자신보다 키가 크거나 같은 인원수를 오름차순으로 한다.

우선순위 큐에서 키가 크면서 자신보다 키가 크거나 같은 인원수가 작은 순서대로 꺼낼 수 있다. 자신보다 키가 크거나 같은 인원수를 리스트의 인덱스로 활용할 수 있어서 우선순위 큐에서 꺼낸 요소는 바로 리스트에 들어갈 수 있다.

<br>

```
[[6, 0], [7, 0], [7, 1]]
```

예를 들어 people 배열이 위와 같다고 가정한다. 키가 크면서 자신보다 키가 크거나 같은 인원수는 작은 순서대로 우선순위 큐에서 꺼내면 [7, 0], [7, 1], [6, 0] 순서대로 나온다. [7, 0] 을 0번 인덱스의 리스트로 넣고 [7, 1] 을 1번 인덱스로 넣으면 [7, 0], [7, 1] 순서대로 리스트에 들어왔다. 이어서 [6, 0] 을 0번 인덱스에 넣으면 [6, 0], [7, 0], [7, 1] 순서대로 리스트에 들어오고 이는 정답과 일치한다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


# LeetCode

## 297. Serialize and Deserialize Binary Tree

이진 트리를 문자열로 변환하고, 변환한 문자열을 이진 트리로 변환해야 한다.

<br>

### Python

#### 첫번째 풀이

##### serialize

BFS 로 탐색한다. 데크에 root 노드를 넣고 데크가 빌 때까지 while 문을 반복한다. 

데크에서 꺼낸 노드가 None 이 아니면 해당 노드의 val 값을 리스트에 넣고 데크에는 노드의 왼쪽, 오른쪽 자식을 넣는다. 노드가 None 이라면 노드가 없다는 것을 표현하기 위해 리스트에 # 를 넣었다. 문자열로 리턴하기 위해 None 은 문자열로 변환이 되지 않아서 None 대신 # 를 넣었다.

<br>

##### deserialize

```
Your Codec object will be instantiated and called as such:
ser = Codec()
deser = Codec()
ans = deser.deserialize(ser.serialize(root))
```

코드 입력 란에 주석으로 된 설명을 보면 serialize 를 호출하고 받은 값을 deserialize 함수의 인자로 넣는다.

<br>

문자열인 deserialize 함수의 파라미터를 리스트로 변환한 후에 리스트의 첫번째 요소를 TreeNode 로 변환하고 데크에 담는다. serialize 함수에서 리스트에 루트 노드부터 담기 때문에 리스트의 첫번째 요소는 루트 노드다.

데크가 빌 때까지 while 문을 돌면서 리스트의 인덱스를 한 칸씩 늘려가면서 탐색한다. 데크에서 꺼낸 노드의 왼쪽, 오른쪽 자식 노드를 찾는다.

데크에서 꺼낸 노드가 루트 노드고 해당 노드부터 left, right 변수에 객체를 이어가는 형태다. 그리고 이 left, right 변수에 담긴 객체들이 다시 데크에 들어가기 때문에 객체 참조에 의해 전체 트리를 구성할 수 있다.

<br>

### Java

#### SerializeAndDeserializeBinaryTree297

교재의 풀이를 참고했다. 데크를 이용해서 BFS 로 풀이할 수 있다.

<br>

##### serialize

TreeNode 를 문자열로 변환해야 한다. StringBuilder 를 이용해서 문자열을 모은다. StringBuilder 에 루트 노드 값을 먼저 넣고 루트 노드와 콤마(",")를 데크에 넣은 뒤, 데크가 빌 때까지 while 문을 돌면서 자식 노드를 조회한다.

데크에서 꺼낸 노드가 왼쪽 자식노드가 있으면 왼쪽 자식노드 값과 콤마를 넣고, 왼쪽 자식노드가 없으면 TreeNode 의 값과 구분하기 위해 #과 콤마를 넣는다.

데크에서 꺼낸 노드가 오른쪽 자식노드가 있으면 오른쪽 자식노드 값과 콤마를 넣고, 오른쪽 자식노드가 없으면 TreeNode 의 값과 구분하기 위해 #과 콤마를 넣는다.

<br>

##### deserialize

문자열을 TreeNode 로 변환해야 한다. 

콤마를 기준으로 split 해서 문자열을 분리하고, 분리한 문자열의 첫번째 인덱스 값으로 루트 노드를 만든다.

루트 노드를 데크에 넣은 뒤 데크가 빌 때까지 while 문을 돌면서 자식 노드를 생성한다. 인덱스를 별도의 변수를 둬서 왼쪽, 오른쪽 자식노드를 생성할 때 인덱스를 1씩 올려간다.

데크에서 꺼낸 노드의 왼쪽 자식노드를 만들기 위해 인덱스 값이 # 이 아니면 왼쪽 자식노드를 생성하고 왼쪽 자식노드를 데크에 넣는다.

데크에서 꺼낸 노드의 오른쪽 자식노드를 만들기 위해 인덱스 값이 # 이 아니면 오른쪽 자식노드를 생성하고 오른쪽 자식노드를 데크에 넣는다.

<br>

#### SerializeAndDeserializeBinaryTree297_2

어려운 문제였다. 교재와 유사하지만 조금 다른 방법으로 직접 풀이를 했으나 시간 초과에 걸려서 통과하지 못했다. 큐를 이용해서 BFS 로 접근하는 방식은 동일했으나 자식 노드에 접근하는 방식이 조금 달랐다.

자식 노드에 접근하는 방식으로 마치 힙을 배열로 관리하는 것처럼 1번 인덱스부터 시작해서 왼쪽과 오른쪽 자식 노드에 접근할때 부모 인덱스 X 2 와 부모 인덱스 X 2 + 1 을 적용하려 했다. 해당 풀이를 제출했을 때 시간초과가 걸렸다. 한쪽으로 길게 늘어지는 트리형태일때 인덱스를 채우기 위해 찍어야하는 값이 너무 많아졌다.

이 방법 대신 교재의 풀이를 참고해서 자식 노드에 접근하는 방식을 변경했다.

<br>

##### serialize

루트 노드를 큐에 넣은 뒤 큐가 빌 때까지 반복한다. 맨 처음 큐에서 꺼내면 루트 노드가 나오고 왼쪽, 오른쪽 자식 노드의 존재 여부를 검사해서 존재하지 않으면 null 임을 판단할 수 있도록 -1001 을 넣고, 존재하면 해당 자식 노드의 값을 넣었다.

부모 인덱스 X 2 혹은 부모 인덱스 X 2 + 1 방식을 사용하지 않기 때문에 null 인 노드 이후는 더 이상 추가로 탐색하지 않도록 큐에 넣지 않는다. 다만 해당 노드가 null 임을 판단하기 위해 -1001 을 넣기만 한다.

<br>

##### deserialize

data 의 첫번째 값으로 루트 노드를 생성한 후 루트 노드를 큐에 담고 큐가 빌 때까지 반복한다. 루트 노드가 0번 인덱스라 큐에서 탐색은 1번 인덱스부터 시작한다. 루트부터 왼쪽, 오른쪽 자식 노드 순서로 순차적으로 data 에 값이 들어있기 때문에 인덱스를 1씩 늘려가면서 탐색한다.

큐에서 꺼낸 노드의 왼쪽 자식 노드의 여부를 data 의 인덱스에 해당하는 값으로 판단한다. null 이 아니면 왼쪽 자식노드를 생성하여 큐에 넣고 인덱스를 1 증가시킨다. null 이면 왼쪽 자식노드를 생성하지 않고 인덱스를 1 증가시킨다. 그리고 오른쪽 자식 노드의 여부를 인덱스에 해당하는 값으로 판단하고 null 여부에 따라 오른쪽 자식노드 생성 및 큐에 넣는 여부를 결정한 후에 인덱스를 1 증가시킨다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


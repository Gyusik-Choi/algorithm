# LeetCode

## [349. Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/)

### Python

#### 첫번째 풀이

딕셔너리를 이용해서 풀이했다.

nums1 의 요소를 딕셔너리에 넣으면서 값을 1로 설정했다. 

nums2 의 요소가 딕셔너리에 없으면 제외하고 딕셔너리에 있으면 해당 키의 값을 2로 설정했다.

딕셔너리에서 값이 2인 키만 리스트로 묶어서 리턴한다.

<br>

#### 두번째 풀이

교재를 참고해서 이진탐색을 활용했다.

이진탐색을 하려면 리스트가 정렬되어야 한다. 

두 리스트 중 하나를 정렬하고 나머지 리스트의 요소가 정렬된 리스트에 존재하는지 이진탐색으로 찾는다.

<br>

#### 세번째 풀이

교재를 참고해서 투포인터를 활용했다.

두 리스트를 정렬하고 두 리스트에 각각의 포인터를 둔다.

각 포인터가 가리키는 값을 비교해서 같으면 포인터 모두 1칸씩 앞으로 이동한다. 값이 다르면 더 작은 값을 가리키는 포인터를 1칸 앞으로 이동해서 보다 큰 값을 가리키도록 한다.

포인터가 하나라도 리스트의 마지막 인덱스를 넘어가면 탐색을 종료한다.

<br>

### Java

#### IntersectionOfTwoArrays349

해시맵을 이용해서 풀이했다. 

nums1 의 요소를 key 로 하고 1을 value 로 해시맵에 넣는다. 중복되는 요소라도 value 를 1로 계속 넣어서 value 를 1로 유지했다.

nums2 의 요소가 해시맵의 key 로 존재하면 해당 key 의 값을 2로 설정했다. 여기서도 마찬가지로 중복되는 요소라도 value 를 2로 계속 넣어서 value 를 2로 유지했다.

nums1 에만 있고 nums2 에는 없는 key 면 value 가 1이다.

해시맵을 스트림을 통해 순회하면서 value 가 2인 key 만 남겨서 배열로 변환한뒤 리턴한다.

<br>

#### IntersectionOfTwoArrays349_2

정렬과 이진 탐색을 이용해서 풀이했다. 

이진 탐색을 하려면 정렬이 되어 있어야 해서 둘 중 하나의 배열만 정렬한 뒤, 정렬하지 않은 다른 배열의 요소를 정렬한 배열에서 이진 탐색으로 조회했다.

이진 탐색으로 조회해서 존재하는 요소는 해시셋에 넣었다. 이진 탐색을 마치면 해시셋을 스트림으로 Integer 타입을 int 로 변환한 뒤 배열로 변환해서 리턴한다.

<br>

#### IntersectionOfTwoArrays349_3

IntersectionOfTwoArrays349_2 와 동일한 방식으로 풀이했다. 언어만 Java 에서 Kotlin 으로 바꿔서 풀이했다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


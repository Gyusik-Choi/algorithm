# LeetCode

## 77. Combinations

### Python

#### 첫번째 풀이

재귀적으로 탐색하면서 조합을 구했다.

cnt 로 갯수를 늘려주면서 갯수가 k 만큼이면 temp 의 값을 복사한 리스트를 combs 에 추가한다.

재귀 호출을 할 때 for 문의 num 을 1 증가한 값을 인자로 넣는다. 다음 재귀 호출에서 인자로 넣은 num + 1 부터 n 까지 for 문을 돌게 되면서 num 이하의 값이 선택되지 않도록 한다.

<br>

#### 두번째 풀이

첫번째 풀이와 마찬가지로 재귀적으로 탐색한다.

첫번째 풀이와의 차이점은 재귀 호출 이전과 이후에 temp 리스트에 append, pop 을 하는 과정이 없다. temp 의 크기를 k 만큼으로 고정한 후에 값을 넣어준다. 값을 넣은 인덱스를 idx 변수로 관리한다. idx 변수를 재귀 호출시 1씩 증가시키고 idx 가 k 와 같으면 temp 의 값을 복사한 리스트를 combs 에 추가한다.

<br>

### Java

#### Combinations77

조합을 배열로 구했다. 리턴 타입을 맞추기 위해 리스트에 넣을 때 배열을 리스트로 변환해서 넣는다.

배열은 인덱스를 관리해야 하는 불편함은 있으나, 요소를 제거를 하지 않고 다른 값으로 덮어쓸 수 있는 편함도 있다.

<br>

#### Combinations77_2

전체적인 풀이방법은 Combinations77 와 같다. 차이는 조합을 배열이 아닌 리스트로 구했다. 정답을 구하는 리스트에 넣을 때 참조로 인해 리스트의 값이 변하지 않도록 새 리스트로 변환해서 넣는다.

<br>

### Kotlin

#### Combinations77

Java 의 Combinations77_2 과 동일한 방식을 사용했다. 자바에서 코틀린으로 변환하면서 중첩함수를 사용했다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


# LeetCode

## [240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/)

### 첫번째 풀이

이진탐색으로 풀이했다.

2차원 리스트를 for 문을 돌면서 내부 요소인 1차원 리스트의 갯수만큼 이진탐색을 수행한다.

N 개의 1차원 리스트를 logN 으로 이진 탐색해서 NlogN 의 시간 복잡도가 나온다.

<br>

### 두번째 풀이

교재의 풀이를 참고했다.

첫번째 행의 마지막 열을 기준으로 탐색한다.

해당 인덱스의 숫자가 target 과 같으면 바로 True 를 리턴한다. 해당 인덱스의 숫자가 target 보다 작으면 더 큰 값을 찾기 위해 행을 1 더한다. 해당 인덱스의 숫자가 target 보다 크면 더 작은 값을 찾기 위해 열을 1 뺀다.

<br>

### 세번째 풀이

교재의 풀이를 참고했다.

any 내장 함수를 이용해서 리스트에 찾는 요소가 있는지 검사한다. or 연산과 유사해서 하나라도 True 면 True 를 리턴한다.

<br>

#### 풀이하기 어려운 방법 1, 2

1)열을 기준으로 이진 탐색 후 해당 열에서 행을 기준으로 이진 탐색을 하는 방법이나 2)행을 기준으로 이진 탐색 후 해당 행에서 열을 기준으로 이진 탐색을 하는 방법을 생각할 수 있으나 둘 다 해당 위치에서 찾지 못할 수 있다. 해당 행이나 열에 찾는 숫자가 있다는 보장이 없어서 다른 행이나 열에 있을 수 있기 때문이다.

<br>

```
1   2   3
8   9   11
10  11  12
```

위와 같은 숫자가 있다고 하자.

10을 찾는다고 하면 10은 첫번째 열의 세번째 행에 있다.

1)방법을 예로 들어 열을 기준으로 이진 탐색하면 기준 열은 맨 마지막 열인데 해당 열에서 행을 기준으로 이진 탐색하면 찾는 숫자는 없다. 다른 열에 찾는 숫자가 있다. 이전 열의 마지막 숫자가 다음 열의 첫번째 숫자보다 클 수 있다.

<br>

#### 풀이하기 어려운 방법 3

첫번째 행의 첫번째 열의 값에서 출발하면 정답을 찾기가 쉽지 않다. 첫번째 행의 마지막 열의 경우 왼쪽은 더 작은 값, 아래는 더 큰 값이 보장되는데 첫번째 행의 첫번째 열은 오른쪽도 더 큰 값, 아래도 더 큰 값이라 어디로 이동해야할지 알 수 없다.


# LeetCode

## 1. Two Sum

2차 for 문을 사용하면 O(N^2) 시간 복잡도가 발생한다. 

O(N) 으로 풀이할 수 있는 방법이 있어서 해당 방법으로 풀이했다.

for 문을 돌면서 딕셔너리에 각 원소를 키로 원소의 인덱스를 값으로 해서 넣는다. 그리고 다시 for 문을 돌면서 target 에서 원소를 뺀 값이 딕셔너리에 있고 이 값을 딕셔너리의 키로 조회한 값이 해당 for 문의 인덱스와 같지 않다면 정답이 된다.

여기서 target 에서 원소를 뺀 값을 딕셔너리의 키로 조회한 값이 해당 for 문의 인덱스와 같지 않은지를 비교하는 이유는 자기 자신을 조회할 경우를 피하기 위해서다. 예를 들어 target 이 10 이고 num 이 5라고 하면 num 과 target - num 이 같은 값이 된다. 이런 경우를 피하려고 해당 비교를 추가한다.

처음에 target 에서 원소를 뺀 값을 입력으로 주어진 nums 리스트에서 찾으려고 했는데 이 보다 딕셔너리에서 찾는게 훨씬 빠르다. 배열에서 in 으로 찾으려면 O(N) 시간 복잡도가 필요한데 딕셔너리에서 in 으로 찾으면 O(1) 로 알 수 있다.

<br>

### Java

#### TwoSum1

투포인터를 활용했다. 투포인터로 풀이하기 위해서는 정렬된 배열이여야 한다. 

이 문제는 인덱스를 반환해야 하고, 정렬할 경우 인덱스가 바뀔 수 있어서 2차원 배열을 따로 만들어서 2차원 배열에 값과 인덱스를 1차원 배열로 묶어서 넣는다.

2차원 배열을 정렬한 후 투포인터로 탐색한다. 시작과 끝 인덱스에서 시작해서 두 인덱스가 가리키는 값의 합을 target 과 비교한다. 

합이 target 보다 크면 보다 작은 합을 만들기 위해 끝 인덱스를 왼쪽으로 한 칸 이동하고, 합이 target 보다 작으면 시작 인덱스를 오른쪽으로 한 칸 이동한다. 합이 target 과 같은 인덱스를 반환한다.

<br>

#### TwoSum1_2

해시맵을 이용한다. 해시맵에 키와 값으로 nums 의 숫자와 인덱스를 넣는다.

nums 를 for 문을 돌면서 target 에서 for 문의 요소를 뺀 값이 해시맵에 존재하고 해시맵에 존재하는 키의 값이 for 문의 요소와 동일한 인덱스가 아니라면 정답이 된다.

<br>

#### TwoSum1_3

TwoSum1_2 의 풀이를 개선했다. TwoSum1_2 와 달리 한번의 for 문으로 풀이하고 인덱스가 자신의 인덱스와 다른지 비교하지 않는다.

for 문을 돌면서 for 문의 요소는 해시맵에 넣지 않고 target 에서 for 문의 요소를 뺀 값이 해시맵에 존재하는지 검사한다. 자신은 아직 해시맵에 들어가지 않아서 해시맵에 해당 키가 존재하면 자신이 아니므로 별도의 값을 검사하지 않고 정답을 찾을 수  있다.

<br>

### Kotlin

#### TwoSum1

자바의 TwoSum1_3 풀이와 동일한 방식으로 풀이했다. 

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰
# LeetCode

## [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)

### Python

#### 첫번째 풀이

10진수에서 2진수를 구하는 연산을 활용했다.

10진수 n 이 0이 될 때까지 2로 나누면서 나머지가 1인 횟수를 리턴했다.

<br>

#### 두번째 풀이

bin 내장함수를 이용해서 10진수 n 을 2진수로 변환하고 count 내장함수로 '1' 의 갯수를 셌다. bin 내장함수로 2진수 변환한 결과는 문자열로 리턴되기 때문에 문자열 '1' 을 센다.

<br>

#### 세번째 풀이

교재의 풀이를 참고했다.

<br>

##### 이진수의 하위 비트 1을 하나씩 제거

한 이진수에서 1을 빼면 하위 비트를 기준으로 1이 있는 비트까지 반전된다.

<br>

```
  10000100
- 00000001
----------
  10000011
```

예를 들어, 이진수 10000100 에서 1을 빼면 최하위 비트부터 가장 먼저 1이 나오는 6번째 비트까지 반전된다.

<br>

```
10000100 & 10000011 = 10000000
```

이진수 a 와 이진수 a 에서 1을 뺀 이진수 b 의 and 연산은 반전된 비트는 모두 0으로 변하고 반전되지 않은 비트는 그대로 유지된다.

한 이진수와 해당 이진수에서 1을 뺀 이진수의 and 연산은 이진수의 1이 1개 줄어드는 결과가 나타난다. 이를 바탕으로 n이 0이 될 때까지 n - 1과 and 연산한 횟수를 리턴하면 정답을 구할 수 있다.

<br>

### Java

#### NumberOf1Bits191

Integer 클래스의 bitCount 메소드는 인자로 들어오는 int 의 이진수 1의 갯수를 리턴한다. 해당 메소드의 결과를 리턴한다.

<br>

#### NumberOf1Bits191_2

NumberOf1Bits191 의 풀이가 자바에 제한적인 풀이라면 이번 풀이는 언어와 관계없이 범용적인 풀이다.

n 과 n - 1 을 AND 연산한 결과를 다시 n 에 할당하여 n 이 0이 될 때까지 반복하는 횟수를 리턴한다.

n 이 1 이상의 정수인 경우 n 과 n - 1 을 AND 연산하면 n 의 1 비트 갯수가 AND 연산하기 이전의 n 의 1 비트 갯수보다 1 감소한다.

<br>

```
  1010
-    1
-------
  1001
```

이진수에서 1을 빼면 최하위 비트부터 최하위 1이 나오는 위치까지 비트가 반전된다.

<br>

```
  100100
-      1
---------
  100011
```

1010 대신 다른 숫자를 적용해도 마찬가지다. 100100 에서 1을 빼도 최하위 비트의 1까지 이진수가 반전되는 것을 확인할 수 있다.

<br>

이진수로 표현한 1 이상의 정수에서 1을 빼면 최하위 1이 나올 때까지 비트가 반전된다. 

최하위 1이 나올 때까지 0을 1이되고, 1은 0이 된다. 최하위 1이 나올 때까지 비트가 반전되기 때문에 한 개의 1만 0이 되고 나머지는 모두 0에서 1로 바뀐다.

1을 빼기 전의 정수와 1을 뺀 정수를 AND 연산하면 비트가 반전되지 않은 비트까지는 원래 비트 값 그대로 나오게 되고 반전된 비트부터는 0으로 바뀐다.

그래서 n 과 n - 1 을 AND 연산하면 비트의 1 갯수가 1씩 줄어든다. n 이 0이 될 때까지 반복하면 n 의 비트 1 갯수를 구할 수 있다.

<br>

### Kotlin

#### NumberOf1Bits191

이진수의 1을 세주는 countOneBits 메소드를 사용했다.

<br>

#### NumberOf1Bits191_2

직접 이진수로 변환하면서 1이 몇개인지 셌다.

<br>

<참고>

파이썬 알고리즘 인터뷰

https://velog.io/@doontagi/%EC%9D%B4%EC%A7%84%EC%88%98-%EB%A7%88%EC%A7%80%EB%A7%89-%EB%B9%84%ED%8A%B8%EC%99%80-and%EC%97%B0%EC%82%B0

자바 알고리즘 인터뷰




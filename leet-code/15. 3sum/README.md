# LeetCode

## 15. 3Sum

투 포인터를 활용했다.

오름차순 정렬을 한 후 for 문을 돌면서 for 문의 다음 인덱스부터 마지막 인덱스 사이를 투 포인터로 탐색한다. 

세 수를 더해서 0보다 크면 값을 줄여주기 위해 가장 큰 숫자가 있는 오른쪽 인덱스를 한 칸 줄인다. 세 수를 더해서 0보다 작으면 값을 늘리기 위해 왼쪽 인덱스를 한 칸 늘린다.

동일한 값이 중복으로 나올 수 있는 점을 유의해야 한다. 예를 들어 입력이 [0, 0, 0, 0] 이 주어지면 [ [0, 0, 0], [0, 0, 0] ] 이렇게 동일한 [0, 0, 0] 이 2개가 나올 수 있다. 이를 막기 위해 for 문의 요소가 이전 요소와 같으면 탐색을 하지 않고 다음 요소로 넘어간다. for 문의 요소가 아니라 투 포인터로 사용하는 인덱스는 각각 이전 인덱스와 같다고 해서 아예 다음 for 문의 요소로 넘어가는게 아니라 left 와 right 가 같아지지 않는 범위 내에서 다른 숫자가 나올 때까지 인덱스를 (왼쪽의 경우) 늘리거나 (오른쪽의 경우) 줄여나간다.

<br>

### Java

바깥 while 문을 투포인터로 left, right 2개 변수를 두고 안쪽 while 문이 종료되면 left, right 의 합이 0보다 작으면 left 를 이동하고, 합이 0보다 크거나 같으면 right 를 이동했다. 이 방법은 모든 경우를 검사하지 못하는 상황이 발생했다.

<br>

```
[-4, -3, -2, -1, -1, 0, 0, 1, 2, 3, 4]
```

이런 입력이 주어졌다고 가정한다. 

처음에 left 는 -4, right 는 4를 바라본다. [-4, 0, 4] 를 구하고 -4와 4의 합이 0이라 right 를 이동한다.

left 는 -4, right 는 3을 바라본다. [-4, 1, 3] 를 구하고 -4와 3의 합이 -1이라 left 를 이동한다.

left 는 -3, right 는 3을 바라본다. 여기서 문제가 발생한다. -3의 경우 right 가 4인 경우도 봐야 하는데 right 가 이미 이동해서 이를 볼 수 없다.

그래서 바깥쪽은 while 문 대신 for 문으로 돌면서 투포인터가 아닌 하나씩 이동하는 방식으로 변경했다.

<br>

그리고 HashSet 으로 중복을 제거할 수도 있으나 for 문과 while 문 안에서 직접 중복 요소를 건너뛰는게 훨씬 더 빠르다. 약 20배 가까이 차이가 났다.

<br>

#### ThreeSum15_3

교재의 풀이보다 속도가 20배 정도 느렸다.

2차 for 문을 돌면서 합을 0으로 만들 수 있는 요소를 이진 탐색으로 찾는 방식으로 풀이했다.

교재의 풀이가 1차 for 문을 돌면서 left, right 의 중복 요소를 while 문으로 빠르게 제거하면서 시간이 훨씬 빨랐다.

이 풀이는 2차 for 문을 돌면서 2차 for 문의 요소가 1차 for 문의 요소와 같으면서 직전 1차 for 문의 요소와 같으면 넘어갔다. 예를 들어, [1, 1, 1, 2] 가 있을 때 2차 for 문의 요소가 세번째 1일때의 경우다.

문제의 입력으로 0이 3000개가 나왔을때 시간 초과가 발생하는 부분을 개선하기 위해 합이 0일 때 같은 요소에 대해서 검사하지 않도록 mid 와 mid - 1 이 같으면 while 문을 break 로 빠져나온다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


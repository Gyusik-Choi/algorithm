# LeetCode

## [621. Task Scheduler](https://leetcode.com/problems/task-scheduler/)

### Python

어려운 문제였다.

<br>

#### 첫번째 풀이

교재의 풀이를 참고했다.

Counter 모듈을 활용해서 우선순위 큐처럼 풀이했다. n 간격을 유지하면서 최소 간격으로 모든 태스크를 실행하기 위해 태스크의 갯수가 많은 태스크를 우선적으로 실행한다.

갯수가 적은 태스크를 먼저 실행하면 n 간격을 유지하기 위한 태스크를 충분히 사용할 수 없다. 갯수가 많아야 한 태스크가 나온 뒤 다른 태스크를 통해 n 간격을 유지할 수 있다. n 간격을 유지하기 위해서는 서로 다른 태스크를 번갈아서 실행시켜야 하는데 갯수가 적은 태스크부터 실행하면 갯수가 많은 태스크부터 실행했을 때보다 더 빨리 태스크의 종류가 줄어들면서 번갈아서 실행할 태스크가 없어진다.

<br>

```python
tasks = [A, A, A, B, B, C] 
n = 1
```

예를 들어, 위와 같은 입력이 주어졌을때 태스크 숫자가 많은 순서부터 실행하면 A, B, C, A, B, A 의 순서로 idle 없이 태스크를 모두 실행할 수 있다.

반면에 태스크 숫자가 적은 순서부터 실행하면 C, B, A, B, A, idle, A 의 순서로 idle 이 추가돼서 태스크 숫자가 많은 순서부터 실행했을 때보다 간격이 더 길다.

<br>

```
tasks = [A, A, A, B, C, D]
n = 2
```

위의 입력은 7이 정답이다. 실행 방법에 따라 태스크의 실행 순서는 조금 다를 수 있다. A, B, C, A, D, idle, A 이것도 가능하고 A, B, idle, A, C, D, A 이것도 가능하다.

무조건 태스크 숫자가 많은 순서대로만 실행하면 안되고 태스크 숫자가 많은 순서대로 실행할 범위를 정해야 한다. 무조건 태스크 숫자가 많은 순서대로만 실행하면 idle 이 오히려 늘어날 수 있다.

위의 입력을 태스크 종류별로 차례대로 갯수가 많은 순서대로 실행하면 A, B, C, D, A, idle, idle, A 가 된다. n 간격을 무시하고 태스크 종류별로 갯수가 많은 순서대로만 처리하면 안 된다.

n 범위만큼 태스크 갯수가 많은 순서대로 실행하면 A, B, idle, A, C, idle, A, D 가 된다. 이 방식은 간격이 8이 된다. n 범위만큼 실행해도 정답이 아닌 경우가 있다.

위의 입력은 A가 3, B, C, D 가 1개다. n 범위만큼 실행할 때 n 이 2면 첫번째는 A, B 가 나오고 그 다음 n 간격에서는 A, C 가 되는데 이때 n 간격을 유지하기 위해 바로 A 가 나오지 못하고 idle 이 먼저 나온 후 A, C 가 나온다. 그리고 다음 n 범위는 A, D 인데 이때도 n 간격 유지를 위해 A 가 바로 나오지 못하고 idle 이 나온 후 A, D 가 나온다. 그래서 이 방식으로 실행한 태스크 순서는  A, B, idle, A, C, idle, A, D 가 된다.

<br>

n 범위만큼 실행하지 않고 n + 1 범위만큼 태스크가 많은 태스크부터 실행하는 방식을 사용한다. n + 1 범위만큼 모두 태스크를 꺼내면 idle 이 없이 태스크를 실행할 수 있다는 의미다. n + 1 범위만큼 태스크를 모두 꺼낼 수 없으면 태스크를 꺼내지 못한 숫자만큼 idle 이 나와야 한다.

n + 1 범위 중 몇개의 idle 이 나왔는지를 판단하기 위해 Counter 모듈의 most_common 함수를 이용해서 값이 큰 순서대로 키를 꺼낸다. 만약에 키의 갯수가 n + 1 이 안되면 n + 1 만큼 꺼낼 수 없게 된다. for 문에서 요소를 꺼낼 때마다 sub_count 변수에 1씩 더한뒤 for 문이 끝나면 n + 1 에서 sub_count 를 뺀 숫자가 idle 의 갯수가 된다. n  + 1 만큼 for 문의 요소를 모두 꺼내면 sub_count 의 값도 n + 1 이 돼서 n + 1 에서 sub_count 를 빼면 0이 된다.

<br>

#### 두번째 풀이

[이분](https://withhamit.tistory.com/419)의 풀이를 참고했다. 이분이 c++ 로 풀이하면서 이용한 map 대신 Counter 모듈을 사용해서 보다 간략하게 풀이했다.

task 갯수가 가장 많은 태스크를 갯수만큼 n 간격으로 배치한 후 생성된 간격들을 나머지 태스크로 채워나가는 방식이다.

<br>

```python
tasks = [A, A, A, B, B, C]
n = 2
```

위와 같은 입력이 주어지면 task 갯수가 가장 많은 태스크는 A 고 _ 를 간격이라고 하면 A _ _ A _ _ A 를 만들 수 있다. _ 는 다른 태스크로 채우거나 idle 이 될 수 있다.

A를 n 간격으로 배치하면 n 간격만큼 띄워진 공간의 갯수는 A 의 갯수 - 1이다. A _ _ A _ _ A 에서 A 간 공간의 갯수는 2고 이는 태스크 A 의 갯수인 3에서 1을 뺀 값과 동일하다.

채워야할 간격의 수는 (task 갯수가 가장 많은 태스크 갯수 - 1) X n 이다. A _ _ A _ _ A 에서 채워야할 간격의 수는 4다. A 간 공간의 갯수인 2는 각각 2개의 빈 간격으로 구성되므로 2 X 2 인 4다.

나머지 태스크인 B, C 로 _ 를 채운다고 할 때 각 태스크마다 채울 수 있는 _ 의 갯수는 task 갯수가 가장 많은 태스크 갯수 - 1와 태스크의 task 갯수 중 더 작은 값이다. 

A _ _ A _ _ A 를 B 로 채운다고 할 때 B 는 4개 중 2개를 채울 수 있다.

<br>

```
tasks = [A, A, A, B, B, B]
n = 3
```

다른 예시로 나머지 태스크로 _ 를 채우는 경우를 살펴보겠다.

우선 A 와 B 의 태스크 숫자가 같은데 이 중 A 로 빈 간격을 만들면 A _ _ A _ _ A 가 된다.

이를 B 로 채운다고 할 때 B 로 채울 수 있는 빈 간격의 수는 2다. 

<br>

```
A B B A B _ A | B
```

B 는 간격 4개 중 2개만 채울 수 있다. | 뒤의 B 는 n 간격을 유지하기 위해 빈 간격을 벗어난 위치에 놓을 수 밖에 없다. 이처럼 task 갯수가 가장 많은 태스크 갯수 - 1 보다 나머지 간격을 채우려는 태스크의 갯수가 더 많은 경우는 최대 task 갯수가 가장 많은 태스크 갯수 - 1 만큼만 채울 수 있다.

A 사이의 공간 하나에 특정 태스크를 최대 하나만 넣을 수 있어서 이 특정 태스크로 채울 수 있는 빈 공간의 갯수는 A 사이의 공간 갯수를 넘을 수 없다.

<br>

```
tasks = [A, A, A, B, B, C, C, D]
n = 2
```

max_idle 를 (task 갯수가 가장 많은 태스크 갯수 - 1) X n 로 초기화 한 후 나머지 태스크들을 for 문을 돌면서 task 갯수가 가장 많은 태스크 갯수 - 1와 태스크의 task 갯수 중 더 작은 값으로 max_idle 값을 줄여나가는데 이때 max_idle 값이 음수가 될 수 있다.

위의 입력의 경우 max_idle 은 4로 초기화 된다. B, C, D 은 각각 2, 2, 1 씩 max_idle 을 줄이기 때문에 max_idle 은 -1이 된다. 이를 방지하기 위해 max_idle 은 최소 0이 될 수 있도록 관리한다.

<br>

### Java

#### TaskScheduler621

우선순위 큐를 활용해서 풀이했다.

우선순위가 높은 task 가 n 간격을 두고 먼저 나와야 한다. 우선순위 큐에서 task 를 꺼낸 뒤 n 간격만큼 대기한다. 다른 task 를 우선순위 큐에서 꺼낼 수 있다면 꺼내고, 꺼낼 수 없다면 idle 상태로 둔다.

구체적인 구현에 대해서 살펴본다. 먼저 해시맵으로 각 문자의 갯수를 세고 이를 우선순위 큐에 넣는다. 우선순위 큐에 들어가는 요소(task)는 길이 2의 배열로 아스키 코드값과 갯수로 이루어진다.

우선순위 큐의 정렬 기준은 문자 갯수가 내림차순, 아스키 코드값의 알파벳이 오름차순이다. 갯수가 많이 나오고 아스키 코드값이 작은 알파벳일수록 우선순위가 높아진다.

완료한 task 정보를 관리할 리스트를 두고 우선순위 큐가 빌 때까지 while 문을 돈다. 우선순위 큐에서 task 를 꺼내고 해당 task 는 리스트에 넣은 뒤 잠시 대기한다. n 간격동안 for 문을 돌면서 우선순위 큐가 비어있지 않으면 task 를 꺼내고 해당 task 를 리스트와 n 간격 동안 꺼낸 task 를 관리하는 별도의 리스트에 각각 넣는다. 우선순위 큐가 비었다면 idle 상태로 둬야 해서 리스트에 task 와 구분할 수 있도록 음수인 -1을 넣는다.

for 문을 다 돌고나면 우선순위 큐에서 꺼냈던 task 를 다시 우선순위 큐에 넣는다. 우선순위 큐에서 꺼낸 task 는 task 를 하나 완료했기 때문에 갯수 정보를 1 줄여야 한다. 1을 줄인 갯수 정보가 0이라면 해당 알파벳 task 는 모두 완료한 것이라 우선순위 큐에 넣지 않는다.

주의할점은 이렇게 구한 리스트의 길이를 그대로 리턴하면 안 된다. 맨 뒤에 idle 이 있을 수 있어서 이를 제거한 뒤 리스트의 길이를 리턴한다.

<br>

### Kotlin

어려운 문제였다. 우선순위 큐를 활용했다.

우선순위 큐에 String 배열을 넣었다. 문자열 배열은 길이가 2로 첫번째 인덱스는 해당 label 의 갯수를 나타내고 두번째 인덱스는 label 을 나타낸다. 

tasks 배열의 모든 요소들을 우선순위 큐에 넣었다가 시간초과에 걸렸다. 우선순위 큐에 넣고 빼는 작업을 줄이기 위해 동일한 label 은 중복해서 넣지 않고 하나만 넣었다.

String 배열의 경우 먼저 Char 배열을 사용했다가 String 배열로 나중에 바꿨다. 배열에 서로 다른 타입의 요소를 넣을 수 없어서 label 의 갯수를 Char 타입으로 변환해서 넣었다. Char 타입으로 관리하면서 갯수를 줄이기 위해 Char 타입의 값을 정수처럼 뺄셈을 하고 싶었으나 의도대로 제대로 되지 않았다. 이에 대해서는 아직 이해가 부족하다.

풀이를 조금 더 편하게 하기 위해 Char 대신 String 을 사용했다. 뺄셈은 toInt 메소드를 사용해서 String 을 Int 로 변환한 후 1을 빼고 다시 String 타입으로 변환하는 방식을 사용했다.

while 문으로 우선순위 큐가 빌 때까지 반복을 하면서 내부에 추가로 while 문을 우선순위 큐가 삘 때까지 반복했다. 바깥의 while 문이 task 를 스케줄링 하는 한번의 사이클이고 내부의 while 문은 조건에 맞는 task 를 찾는 과정이다. 조건에 맞는 task 를 우선순위 큐에서 바로 찾지 못할 수 있기 때문에 우선순위 큐에서 계속 꺼내야 할 수 있어서 내부 while 문을 추가로 사용하게 된 것이다.

내부 while 문에서 조건에 맞지 않는 task 들은 별도의 리스트에 따로 모아두고 조건에 맞는 task 를 찾고 나서 다시 우선순위 큐에 넣어서 스케줄링 될 수 있도록 했다. 만약에 조건에 맞는 task 를 찾지 못했으면 idle 로 처리한다. 

조건에 맞는 task 여부를 판단하기 위해 schedule 이 완료된 task 들을 모으는 리스트의 길이와 인터벌의 값을 비교해서 더 작은 값만큼 리스트의 마지막부터 해당 값만큼 동일한 task 가 있는지 확인했다. 

예를 들어 schedule 이 완료된 task 들을 모으는 리스트가  [A, B, C] 고 인터벌이 2라고 할 때 리스트의 길이인 3보다 인터벌인 2가 더 작다. 그러면 전체 길이에서 2를 뺀 1부터 리스트의 마지막 인덱스까지의 범위를 비교하게 된다.

또 다른 예를 들어 schedule 이 완료된 task 들을 모으는 리스트가 [A] 고 인터벌이 2라고 할 때 리스트의 길이인 1보다 인터벌인 2가 더 크다. 그러면 전체 길이에서 리스트이 길이인 1을 뺀 0번째 인덱스부터 마지막 인덱스인 0번 인덱스 범위를 비교한다. 이때는 0번 인덱스만 비교하게 되는 것이다.

<br>

<참고>

파이썬 알고리즘 인터뷰

https://withhamit.tistory.com/419

자바 알고리즘 인터뷰


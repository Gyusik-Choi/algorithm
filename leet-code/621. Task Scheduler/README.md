# LeetCode

## [621. Task Scheduler](https://leetcode.com/problems/task-scheduler/)

어려운 문제였다.

<br>

### 첫번째 풀이

교재의 풀이를 참고했다.

Counter 모듈을 활용해서 우선순위 큐처럼 풀이했다. n 간격을 유지하면서 최소 간격으로 모든 태스크를 실행하기 위해 태스크의 갯수가 많은 태스크를 우선적으로 실행한다.

갯수가 적은 태스크를 먼저 실행하면 n 간격을 유지하기 위한 태스크를 충분히 사용할 수 없다. 갯수가 많아야 한 태스크가 나온 뒤 다른 태스크를 통해 n 간격을 유지할 수 있다. n 간격을 유지하기 위해서는 서로 다른 태스크를 번갈아서 실행시켜야 하는데 갯수가 적은 태스크부터 실행하면 갯수가 많은 태스크부터 실행했을 때보다 더 빨리 태스크의 종류가 줄어들면서 번갈아서 실행할 태스크가 없어진다.

<br>

```python
tasks = [A, A, A, B, B, C] 
n = 1
```

예를 들어, 위와 같은 입력이 주어졌을때 태스크 숫자가 많은 순서부터 실행하면 A, B, C, A, B, A 의 순서로 idle 없이 태스크를 모두 실행할 수 있다.

반면에 태스크 숫자가 적은 순서부터 실행하면 C, B, A, B, A, idle, A 의 순서로 idle 이 추가돼서 태스크 숫자가 많은 순서부터 실행했을 때보다 간격이 더 길다.

<br>

```
tasks = [A, A, A, B, C, D]
n = 2
```

위의 입력은 7이 정답이다. 실행 방법에 따라 태스크의 실행 순서는 조금 다를 수 있다. A, B, C, A, D, idle, A 이것도 가능하고 A, B, idle, A, C, D, A 이것도 가능하다.

무조건 태스크 숫자가 많은 순서대로만 실행하면 안되고 태스크 숫자가 많은 순서대로 실행할 범위를 정해야 한다. 무조건 태스크 숫자가 많은 순서대로만 실행하면 idle 이 오히려 늘어날 수 있다.

위의 입력을 태스크 종류별로 차례대로 갯수가 많은 순서대로 실행하면 A, B, C, D, A, idle, idle, A 가 된다. n 간격을 무시하고 태스크 종류별로 갯수가 많은 순서대로만 처리하면 안 된다.

n 범위만큼 태스크 갯수가 많은 순서대로 실행하면 A, B, idle, A, C, idle, A, D 가 된다. 이 방식은 간격이 8이 된다. n 범위만큼 실행해도 정답이 아닌 경우가 있다.

위의 입력은 A가 3, B, C, D 가 1개다. n 범위만큼 실행할 때 n 이 2면 첫번째는 A, B 가 나오고 그 다음 n 간격에서는 A, C 가 되는데 이때 n 간격을 유지하기 위해 바로 A 가 나오지 못하고 idle 이 먼저 나온 후 A, C 가 나온다. 그리고 다음 n 범위는 A, D 인데 이때도 n 간격 유지를 위해 A 가 바로 나오지 못하고 idle 이 나온 후 A, D 가 나온다. 그래서 이 방식으로 실행한 태스크 순서는  A, B, idle, A, C, idle, A, D 가 된다.

<br>

n 범위만큼 실행하지 않고 n + 1 범위만큼 태스크가 많은 태스크부터 실행하는 방식을 사용한다. n + 1 범위만큼 모두 태스크를 꺼내면 idle 이 없이 태스크를 실행할 수 있다는 의미다. n + 1 범위만큼 태스크를 모두 꺼낼 수 없으면 태스크를 꺼내지 못한 숫자만큼 idle 이 나와야 한다.

n + 1 범위 중 몇개의 idle 이 나왔는지를 판단하기 위해 Counter 모듈의 most_common 함수를 이용해서 값이 큰 순서대로 키를 꺼낸다. 만약에 키의 갯수가 n + 1 이 안되면 n + 1 만큼 꺼낼 수 없게 된다. for 문에서 요소를 꺼낼 때마다 sub_count 변수에 1씩 더한뒤 for 문이 끝나면 n + 1 에서 sub_count 를 뺀 숫자가 idle 의 갯수가 된다. n  + 1 만큼 for 문의 요소를 모두 꺼내면 sub_count 의 값도 n + 1 이 돼서 n + 1 에서 sub_count 를 빼면 0이 된다.

<br>

### 두번째 풀이

[이분](https://withhamit.tistory.com/419)의 풀이를 참고했다. 이분이 c++ 로 풀이하면서 이용한 map 대신 Counter 모듈을 사용해서 보다 간략하게 풀이했다.

task 갯수가 가장 많은 태스크를 갯수만큼 n 간격으로 배치한 후 생성된 간격들을 나머지 태스크로 채워나가는 방식이다.

<br>

```python
tasks = [A, A, A, B, B, C]
n = 2
```

위와 같은 입력이 주어지면 task 갯수가 가장 많은 태스크는 A 고 _ 를 간격이라고 하면 A _ _ A _ _ A 를 만들 수 있다. _ 는 다른 태스크로 채우거나 idle 이 될 수 있다.

A를 n 간격으로 배치하면 n 간격만큼 띄워진 공간의 갯수는 A 의 갯수 - 1이다. A _ _ A _ _ A 에서 A 간 공간의 갯수는 2고 이는 태스크 A 의 갯수인 3에서 1을 뺀 값과 동일하다.

채워야할 간격의 수는 (task 갯수가 가장 많은 태스크 갯수 - 1) X n 이다. A _ _ A _ _ A 에서 채워야할 간격의 수는 4다. A 간 공간의 갯수인 2는 각각 2개의 빈 간격으로 구성되므로 2 X 2 인 4다.

나머지 태스크인 B, C 로 _ 를 채운다고 할 때 각 태스크마다 채울 수 있는 _ 의 갯수는 task 갯수가 가장 많은 태스크 갯수 - 1와 태스크의 task 갯수 중 더 작은 값이다. 

A _ _ A _ _ A 를 B 로 채운다고 할 때 B 는 4개 중 2개를 채울 수 있다.

<br>

```
tasks = [A, A, A, B, B, B]
n = 3
```

다른 예시로 나머지 태스크로 _ 를 채우는 경우를 살펴보겠다.

우선 A 와 B 의 태스크 숫자가 같은데 이 중 A 로 빈 간격을 만들면 A _ _ A _ _ A 가 된다.

이를 B 로 채운다고 할 때 B 로 채울 수 있는 빈 간격의 수는 2다. 

<br>

```
A B B A B _ A | B
```

B 는 간격 4개 중 2개만 채울 수 있다. | 뒤의 B 는 n 간격을 유지하기 위해 빈 간격을 벗어난 위치에 놓을 수 밖에 없다. 이처럼 task 갯수가 가장 많은 태스크 갯수 - 1 보다 나머지 간격을 채우려는 태스크의 갯수가 더 많은 경우는 최대 task 갯수가 가장 많은 태스크 갯수 - 1 만큼만 채울 수 있다.

A 사이의 공간 하나에 특정 태스크를 최대 하나만 넣을 수 있어서 이 특정 태스크로 채울 수 있는 빈 공간의 갯수는 A 사이의 공간 갯수를 넘을 수 없다.

<br>

```
tasks = [A, A, A, B, B, C, C, D]
n = 2
```

max_idle 를 (task 갯수가 가장 많은 태스크 갯수 - 1) X n 로 초기화 한 후 나머지 태스크들을 for 문을 돌면서 task 갯수가 가장 많은 태스크 갯수 - 1와 태스크의 task 갯수 중 더 작은 값으로 max_idle 값을 줄여나가는데 이때 max_idle 값이 음수가 될 수 있다.

위의 입력의 경우 max_idle 은 4로 초기화 된다. B, C, D 은 각각 2, 2, 1 씩 max_idle 을 줄이기 때문에 max_idle 은 -1이 된다. 이를 방지하기 위해 max_idle 은 최소 0이 될 수 있도록 관리한다.

<br>

<참고>

파이썬 알고리즘 인터뷰

https://withhamit.tistory.com/419


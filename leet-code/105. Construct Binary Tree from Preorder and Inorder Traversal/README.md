# LeetCode

## [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

### Python

이진탐색트리의 전위 순회와 중위 순회 리스트를 토대로 트리를 구성해야 한다.

전위 순회의 값은 중위 순회의 값을 좌, 우측으로 이등분한다.

전위 순회는 부모, 왼쪽 자식, 오른쪽 자식 순서로 이루어진다. 중위 순회는 왼쪽 자식, 부모, 오른쪽 자식 순서로 이루어진다. 

중위 순회에서 부모 노드는 왼쪽 자식 보다 늦게 탐색한다. 전위 순회 리스트에 담긴 요소들을 순서대로 중위 순회 리스트에서 찾으면 중위 순회를 왼쪽, 오른쪽으로 나눠 가면서 점점 작은 단위로 분할 정복 하듯이 탐색한다.

전위 순회 리스트를 순서대로 탐색하면서 노드를 생성하고 노드를 생성한 요소의 인덱스를 중위 순회 리스트에서 찾는다. 인덱스를 기준으로 리스트의 왼쪽을 왼쪽 자식 노드를 찾기 위한 재귀 호출을 하고, 리스트의 오른쪽을 오른쪽 자식 노드를 찾기 위한 재귀 호출을 한다.

<br>

### Java

#### ConstructBinaryTreeFromPreorderAndInorderTraversal105

전위 순회와 중위 순회의 관계를 파악하는게 중요했다.

전위 순회 배열의 요소를 순차적으로 꺼내서 중위 순회 리스트를 분할 정복해 나간다. 전위 순회 배열의 요소로 중위 순회 배열을 왼쪽, 오른쪽 구간으로 나눈다. 나눠진 왼쪽, 오른쪽 구간을 각각 왼쪽, 오른쪽 자식 노드를 찾기 위한 재귀 호출을 한다.

이 부분이 이해하기 어려웠는데 재귀 호출 속에서 전위 순회 배열의 첫번째 요소를 계속 꺼낸다. 재귀 호출은 나눠진 중위 순회 배열을 기준으로 이루어지는데 재귀 호출에서 전위 순회 배열의 첫번째 요소를 꺼내는게 어떻게 올바른 전위 순회 요소에 대한 접근이 될 수 있을지 궁금했다. 

중위 순회 배열은 전위 순회 배열의 요소에 따라서 왼쪽, 오른쪽 구간이 나눠지고 이를 재귀 호출한다. 전위 순회 배열을 하나씩 꺼내는게 재귀 호출의 순서와 어떻게 딱 맞을 수 있는지 이해하기 어려웠다.

하나의 이진 트리에서 나온 전위 순회, 중위 순회 결과라서 서로 연관되어 있다.

예를 들어 루트 노드가 1, 오른쪽 자식노드가 3, 오른쪽 자식노드의 오른쪽 자식노드가 5라고 가정한다. 이때 전위 순회 결과는 [1, 3, 5] 가 되고 중위 순회 결과도 [1, 3, 5] 가 된다. 

이 트리는 왼쪽 자식노드가 없고 오른쪽 자식노드만 있다. 

전위 순회의 1을 기준으로 중위 순회 배열을 분할하면 왼쪽은 없고 오른쪽에 3, 5 가 있다. 왼쪽 자식노드에 대한 재귀 호출은 중위 순회 배열이 null 이라 전위 순회 요소를 꺼내지 않고 종료된다. 오른쪽 자식노드에 대한 재귀 호출은 중위 순회 배열은 [3, 5] 가 있다. 

전위 순회의 3을 기준으로 중위 순회 배열 [3, 5] 를 분할하면 왼쪽은 없고 오른쪽에 5 가 있다. 왼쪽 자식노드에 대한 재귀 호출은 중위 순회 배열이 null 이라 전위 순회 요소를 꺼내지 않고 종료된다. 오른쪽 자식노드에 대한 재귀 호출은 중위 순회 배열은 [5] 가 있다.

전위 순회의 5를 기준으로 중위 순회 배열을 분할하면 왼쪽은 없고 오른쪽에도 없어서 재귀 호출이 되자마자 종료되고 재귀 호출이 끝난다.

전위 순회의 순서는 중위 순회를 분할하고 재귀 호출하는 순서와 일치한다.

만약에 루트 노드가 1, 왼쪽 자식 노드가 3, 오른쪽 자식노드가 5인 경우라면 전위 순회 결과는 [1, 3, 5], 중위 순회 결과는 [3, 1, 5] 가 된다. 이때는 전위 순회의 1을 기준으로 중위 순회 배열을 분할하면 왼쪽에 3 이 있어서 왼쪽의 3을 기준으로 재귀 호출이 되고 이때 전위 순회의 다음 순서는 3이라 역시 전위 순회의 순서와 중위 순회를 분할하고 재귀 호출하는 순서는 일치한다.

<br>

#### ConstructBinaryTreeFromPreorderAndInorderTraversal105_2

전위순회 배열의 요소를 중위순회 배열에서 찾아서 이를 기준으로 트리의 왼쪽, 오른쪽 자식노드로 분할하고 재귀호출 한다.

<br>

```
전위순회 - [3, 9, 17, 20, 15, 7]
중위순회 - [17, 9, 3, 15, 20, 7]
```

위와 같은 입력이 주어졌다고 하면 전위순회의 첫번째 요소인 3은 루트 노드가 되고 중위순회에서 3을 기준으로 루트 노드의 왼쪽 자식노드에 [17, 9], 오른쪽 자식노드에 [15, 20, 7] 이 온다.

여기서 중위순회 뿐만 아니라 전위순회가 있어야 트리를 만들 수 있다. 3을 기준으로 왼쪽, 오른쪽을 나눴는데 이 이후 자식 노드에서도 트리를 구성하려면 전위순회 결과가 필요하다.

앞서 중위순회에서 3을 기준으로 왼쪽, 오른쪽 자식노드를 나눴는데 왼쪽 자식노드의 크기는 2, 오른쪽 자식노드의 크기는 3이다. 이 크기만큼 전위순회도 나눌 수 있다. 전위순회의 첫번째 요소인 3이후 크기 2만큼이 왼쪽 자식노드, 나머지 3만큼이 오른쪽 자식노드가 된다. 여기서 알 수 있는 점은 왼쪽, 오른쪽 자식노드로 나눈 전위순회, 중위순회의 각 요소의 순서는 다르지만 포함하는 요소 자체는 동일하다.

<br>

```
왼쪽 자식노드
전위순회 - [9, 17]
중위순회 - [17, 9]

오른쪽 자식노드
전위순회 - [20, 15, 7]
중위순회 - [15, 20, 7]
```

왼쪽 자식노드와 오른쪽 자식노드를 나눠서 재귀호출을 하면 이제 각 재귀호출별로 앞서 진행한 것과 동일한 방식으로 왼쪽 자식노드, 오른쪽 자식노드를 나눠가면 된다.

예를 들어, 전위순회로 [9, 17], 중위순회로 [17, 9] 가 있을 때 이때 해당 재귀호출에서 루트 노드는 전위순회의 첫번째 요소인 9다. 참고로 이 재귀호출의 경우 앞선 3을 기준으로 나눈 왼쪽 자식노드 재귀호출 구간에서 참조하고 있어서 리턴 결과로 받게 된다. 다시 본론으로 돌아와서 9를 기준으로 중위순회를 나누면 왼쪽 자식노드로 [17] 오른쪽 자식노드로 [] 가 된다. 즉, 왼쪽 자식노드에 17이 오고 오른쪽 자식노드는 없다. 9를 기준으로 왼쪽 자식노드, 오른쪽 자식노드를 재귀호출하면 오른쪽 자식노드는 빈 배열이라 바로 null 이 리턴된다.

<br>

### Kotlin

```
전위순회 - [1, 2, 4, 5, 3, 6, 7, 9, 8]
중위순회 - [4, 2, 5, 1, 7, 9, 6, 8, 3]
```

전위순회, 중위순회 결과가 위와 같다고 가정한다. 

전위순회의 첫번째 값인 1은 중위순회 결과를 왼쪽, 오른쪽으로 분할한다. 그리고 이 1은 중위순회에서는 인덱스 3에 위치하는데 전위순회 인덱스 3은 중위순회의 왼쪽을 포함하는 인덱스다. 중위순회에서 왼쪽에 위치한 4, 2, 5 를 포함한다.

전위순회의 요소를 중위순회에서 찾은 인덱스로 중위순회를 왼쪽, 오른쪽으로 구분할 수 있을 뿐만 아니라 전위순회 또한 왼쪽, 오른쪽으로 구분할 수 있다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰
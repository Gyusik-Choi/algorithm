# LeetCode

## [169. Majority Element](https://leetcode.com/problems/majority-element/)

### Python

#### 첫번째 풀이

과반수가 존재하는 리스트의 경우 리스트를 정렬하면 가운데 인덱스는 반드시 과반수다.

<br>

#### 두번째 풀이

for 문을 돌면서 딕셔너리에 리스트의 각 요소의 갯수를 센다. 해당 요소의 갯수가 리스트 절반 길이보다 큰 경우 for 문을 더 돌지 않고 바로 정답을 리턴한다.

<br>

#### 세번째 풀이

cnt 는 과반수의 갯수, majority 는 과반수를 나타낸다. 

for 문을 돌면서 cnt 가 0이면 과반수가 없는 상태라 cnt 를 1 더해주고 majority 를 해당 요소로 갱신한다. cnt 가 0이 아니면서 majority 가 for 문의 요소와 동일하면 cnt 를 1 더해준다. cnt 가 0이 아니면서 majority 가 해당 요소와 다른 경우 cnt 를 1 뺀다.

만약에 for 문을 돌면서 과반수는 1을 더하고 과반수가 아닌 숫자는 1을 빼면 cnt 는 항상 1 이상이다. 중간에 과반수가 아닌 요소가 더 많이 나와서 majority 가 해당 숫자일 때가 있지만 결국은 과반수에 의해 cnt 가 0이 되고 이때 majority 는 과반수로 바뀐다.

<br>

#### 네번째 풀이

교재의 풀이를 참고했다. 분할 정복 방식으로 풀이한다.

리스트를 요소 하나가 남을 때까지 분할한 뒤 정답이 될 가능성이 있는 후보 하나씩만 리턴해서 병합해나간다.

과반수가 반드시 존재해서 해당 요소가 반드시 최종 후보로 남게 된다.

과반수가 반드시 존재하므로 리스트를 반으로 잘라도 최소 어느 한쪽 리스트는 과반수가 반드시 존재한다. 이 리스트를 다시 분할해도 어느 한쪽은 과반수가 존재한다. 이 과반수는 끝까지 생존해서 최종 후보로 올라가게 된다.

<br>

```python
nums = [2, 1, 1, 1, 2, 2, 2]
```

nums 가 위와 같은 경우 nums 를 분할한 [2, 1, 1, 1], [2, 2, 2] 에서 [2, 1, 1, 1] 에서는 1이 리턴되고, [2, 2, 2] 에서 2가 리턴된다. 1과 2 중에서 과반수는 2라서 결국 정답은 2가 된다.

<br>

```python
nums = [2, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2]
```

nums 의 길이가 길어지면 과반수가 무시되는 경우가 생기지 않을까 생각했지만 분할 정복이라는 컨셉을 생각해보면 그렇지 않음을 알 수 있었다. 

앞선 nums 가 2배가 되더라도 반으로 나눈 [2, 1, 1, 1, 2, 2, 2], [2, 1, 1, 1, 2, 2, 2] 의 최종 후보는 모두 2가 돼서 결국 정답은 2가 된다.

<br>

```python
nums = [2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 3]
# [2, 1, 1, 1, 2, 2, 2]
# [1, 1, 1, 2, 2, 2, 3]
# nums 는 이 2개를 합한 리스트다
```

위의 nums 는 앞선 [2, 1, 1, 1, 2, 2, 2] 에 [1, 1, 1, 2, 2, 2, 3] 를 합친 경우인데 이때 [2, 1, 1, 1, 2, 2, 2] 는 마찬가지로 2를 리턴한다. 2가 과반수를 유지하기 때문에 [1, 1, 1, 2, 2, 2, 3] 가 무엇을 리턴하건 정답은 2가 된다.

<br>

### Java

#### MajorityElement169

해시맵을 이용해서 풀이했다.

nums 를 순회하면서 해시맵으로 각 숫자별 갯수를 구하고, 다시 nums 를 순회하면서 과반수의 숫자를 찾으면 해당 숫자를 리턴한다.

과반수를 구할 때 주의해야 한다. nums 의 길이에서 2를 나누면 안 되고 nums 의 길이에서 1을 더한 뒤 2를 나눠야 한다.

예를 들어, 길이가 7이면 과반수는 4다. 7에서 2를 나누면 3이 돼서 과반수를 구할 수 없다. 7에서 1을 더한 뒤 2를 나누면 과반수를 구할 수 있다.

마찬가지로 길이가 8이면 과반수는 5다. 8에서 2를 나누면 4가 돼서 과반수를 구할 수 없다. 8에서 1을 더한 뒤 2를 나누면 과반수를 구할 수 있다.

<br>

#### MajorityElement169_2

교재의 풀이를 참고했다. 분할정복 방식으로 풀이한다.

처음에 과반수만 리턴하는 방식을 생각하긴 했으나 동일한 갯수는 어떻게 처리해야 할지 몰랐다. 교재의 설명을 통해 이해할 수 있었는데, 과반수가 반드시 존재하기 때문에 과반수는 분할정복에서 최종적으로 생존한다.

문제의 예시입력 중 하나인 [2, 2, 1, 1, 1, 2, 2] 를 보면 첫번째 분할하면 [2, 2, 1, 1] 과 [1, 2, 2] 로 나뉜다. [2, 2, 1, 1] 은 갯수가 동일한데 2와 1 중에서 어떤걸 리턴할 수 있을지 판단하기 어려웠다. 

결론적으로 2와 1 중에서 어떤 숫자를 리턴하더라도 정답을 구하는데 문제가 없다. 설령 [2, 2, 1, 1] 에서 1을 리턴하더라도 [1, 2, 2]에서는 2를 리턴하게 된다. [2, 2, 1, 1] 과 [1, 2, 2]가 합쳐진 리스트에서 low, high 범위만큼 갯수를 다시 세기 때문에 2가 최종적으로 리턴된다.

리스트가 홀수 길이건 짝수 길이건 과반수가 존재하기 때문에 길이 2까지 분할 했을 때 최소한 하나의 과반수 쌍이 존재한다. 이 과반수 쌍은 상위에서 과반수로 계속해서 리턴되면서 마지막까지 올라가서 최종적으로 리턴된다.

<br>

#### MajorityElement169_3

과반수가 존재하는 리스트의 경우 리스트를 정렬하면 가운데 인덱스는 반드시 과반수다.

<br>

<참고>

파이썬 알고리즘 인터뷰

https://ko.wikipedia.org/wiki/%EB%B9%84%EB%91%98%EA%B8%B0%EC%A7%91_%EC%9B%90%EB%A6%AC

https://doozi0316.tistory.com/entry/leetCode-169-Majority-Element-Easy-%ED%92%80%EC%9D%B4

https://kkminseok.github.io/posts/leetcode_Major_Element/

자바 알고리즘 인터뷰


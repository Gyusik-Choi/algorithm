# LeetCode

## [169. Majority Element](https://leetcode.com/problems/majority-element/)

### 첫번째 풀이

과반수가 존재하는 리스트의 경우 리스트를 정렬하면 가운데 인덱스는 반드시 과반수다.

<br>

### 두번째 풀이

for 문을 돌면서 딕셔너리에 리스트의 각 요소의 갯수를 센다. 해당 요소의 갯수가 리스트 절반 길이보다 큰 경우 for 문을 더 돌지 않고 바로 정답을 리턴한다.

<br>

### 세번째 풀이

cnt 는 과반수의 갯수, majority 는 과반수를 나타낸다. 

for 문을 돌면서 cnt 가 0이면 과반수가 없는 상태라 cnt 를 1 더해주고 majority 를 해당 요소로 갱신한다. cnt 가 0이 아니면서 majority 가 for 문의 요소와 동일하면 cnt 를 1 더해준다. cnt 가 0이 아니면서 majority 가 해당 요소와 다른 경우 cnt 를 1 뺀다.

만약에 for 문을 돌면서 과반수는 1을 더하고 과반수가 아닌 숫자는 1을 빼면 cnt 는 항상 1 이상이다. 중간에 과반수가 아닌 요소가 더 많이 나와서 majority 가 해당 숫자일 때가 있지만 결국은 과반수에 의해 cnt 가 0이 되고 이때 majority 는 과반수로 바뀐다.

<br>

### 네번째 풀이

교재의 풀이를 참고했다. 분할 정복 방식으로 풀이한다.

리스트를 요소 하나가 남을 때까지 분할한 뒤 정답이 될 가능성이 있는 후보 하나씩만 리턴해서 병합해나간다.

과반수가 반드시 존재해서 해당 요소가 반드시 최종 후보로 남게 된다.

과반수가 반드시 존재하므로 리스트를 반으로 잘라도 최소 어느 한쪽 리스트는 과반수가 반드시 존재한다. 이 리스트를 다시 분할해도 어느 한쪽은 과반수가 존재한다. 이 과반수는 끝까지 생존해서 최종 후보로 올라가게 된다.

<br>

```python
nums = [2, 1, 1, 1, 2, 2, 2]
```

nums 가 위와 같은 경우 nums 를 분할한 [2, 1, 1, 1], [2, 2, 2] 에서 [2, 1, 1, 1] 에서는 1이 리턴되고, [2, 2, 2] 에서 2가 리턴된다. 1과 2 중에서 과반수는 2라서 결국 정답은 2가 된다.

<br>

```python
nums = [2, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2]
```

nums 의 길이가 길어지면 과반수가 무시되는 경우가 생기지 않을까 생각했지만 분할 정복이라는 컨셉을 생각해보면 그렇지 않음을 알 수 있었다. 

앞선 nums 가 2배가 되더라도 반으로 나눈 [2, 1, 1, 1, 2, 2, 2], [2, 1, 1, 1, 2, 2, 2] 의 최종 후보는 모두 2가 돼서 결국 정답은 2가 된다.

<br>

```python
nums = [2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 3]
# [2, 1, 1, 1, 2, 2, 2]
# [1, 1, 1, 2, 2, 2, 3]
# nums 는 이 2개를 합한 리스트다
```

위의 nums 는 앞선 [2, 1, 1, 1, 2, 2, 2] 에 [1, 1, 1, 2, 2, 2, 3] 를 합친 경우인데 이때 [2, 1, 1, 1, 2, 2, 2] 는 마찬가지로 2를 리턴한다. 2가 과반수를 유지하기 때문에 [1, 1, 1, 2, 2, 2, 3] 가 무엇을 리턴하건 정답은 2가 된다.

<br>

<참고>

파이썬 알고리즘 인터뷰

https://ko.wikipedia.org/wiki/%EB%B9%84%EB%91%98%EA%B8%B0%EC%A7%91_%EC%9B%90%EB%A6%AC

https://doozi0316.tistory.com/entry/leetCode-169-Majority-Element-Easy-%ED%92%80%EC%9D%B4

https://kkminseok.github.io/posts/leetcode_Major_Element/


# LeetCode

## 330. Minimum Height Trees

### Python

최소 높이를 갖는 트리 노드를 찾는 문제다. 트리의 가운데에 있는 노드를 찾아야 한다.

처음에 생각했던 방식은 플로이드 워셜 알고리즘을 사용해서 모든 노드간의 거리를 구한 후 노드마다 다른 노드로 가는 거리가 최소인 노드를 찾는 방식을 생각했다.

그러나 플로이드 워셜 알고리즘의 시간 복잡도는 O(N^3) 이라 최대 노드 갯수가 20000개인 이번 문제에서는 적용할 수 없었다.

<br>

교재의 방식을 참고했다. 교재는 리프 노드를 제거하는 방식으로 풀이한다. 노드의 갯수가 2개 이하로 남을 때까지 리프 노드를 제거하고 남은 노드를 리턴한다.

리프 노드는 연결된 노드가 하나인지 여부로 알 수 있다. 각 노드를 키로 하고 노드마다 연결된 노드들을 값으로 하는 딕셔너리를 만들고 값의 길이가 1이면 리프 노드다.

<br>

처음에 리프 노드를 찾고서 그 다음 while 문으로 진입한다. while 문에서는 앞서 찾은 리프 노드들을 for 문을 돌면서 해당 리프 노드와 연결된 노드간의 연결을 끊는다.

연결을 끊기 위해 리프 노드의 값을 제거한다. 리프 노드라 값이 하나기 때문에 pop 으로 리스트에서 꺼낼 수 있다. pop 으로 꺼낸 노드도 리프 노드와 연결되지 않도록 값에서 리프 노드를 찾아서 제거한다.

리프 노드를 찾아서 제거한 후 곧장 해당 노드 (pop 으로 꺼낸 노드) 도 리프 노드가 됐는지 확인한다. for 문을 다 돌고나서 확인 하는게 아니라 곧장 확인하는 이유는 남은 for 문이 돌면서 리프 노드의 값이 빈 리스트가 돼서 리프 노드인 노드를 제대로 찾을 수 없는 문제가 발생한다.

그래서 while 문 이전에 리프 노드를 먼저 찾는 과정을 while 문 안으로 옮기고 싶었으나 이런 이유로 그렇게 할 방법을 찾지 못했다.

<br>

### Java

#### MinimumHeightTrees310

초기에는 0부터 n-1까지 각각 재귀적으로 최대 높이를 구한 후 이 중 최소값을 구하려고 했으나 시간 초과로 통과하지 못했다.

교재는 풀이를 참고했다. 트리 높이가 가장 낮은 노드는 트리의 가운데에 위치한 노드라 리프 노드부터 제거할 때 마지막까지 남는다.

더 이상 제거할 노드가 없다고 판단하는 while (n > 2) 조건을 이해하기 어려웠다. 높이가 가장 낮은 노드가 3개 이상일 수도 있지 않을까 생각했는데 이는 잘못된 생각이었다. 트리에 남은 노드가 3개 이상이라면 무조건 높이가 다른 노드가 있다. 트리는 순환하지 않는 그래프라 3개 이상의 노드는 높이가 동일할 수 없다.

<br>

#### MinimumHeightTrees310_2

[이분](https://velog.io/@soopsaram/Leetcode-310.-Minimum-Height-Trees)의 풀이를 참고했다. 

교재와 전체적인 풀이 방식은 동일하지만 차이가 있다. 리프 노드를 제거할 때 map 에서 직접 노드를 제거하지 않고 연결된 노드의 갯수를 보관하는 별도의 리스트를 두어 이 리스트의 값을 1씩 뺐다. 그리고 while 문의 조건을 true 로 두고 더 이상 다른 1개의 노드와 연결된 노드가 없는 경우 while 문을 종료하는 방식을 적용했다. 더 이상 다른 1개의 노드와 연결된 노드가 없는 경우는 직전에 구한 노드들이 정답이 된다.

<br>

#### MinimumHeightTrees310_3

MinimumHeightTrees310 와 동일한 방식으로 풀이했다. 처음에는 시간초과가 발생해서 교재의 풀이를 통해 개선할 수 있었다. while 문 안에서 매번 map 의 keySet 이나 values 로 for 문을 도는 로직을 걷어내면서 시간초과가 발생하지 않을 수 있었다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰

https://velog.io/@soopsaram/Leetcode-310.-Minimum-Height-Trees


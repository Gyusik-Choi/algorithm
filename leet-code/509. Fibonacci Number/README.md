# LeetCode

## [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)

피보나치 수를 구하는 문제다. 다양한 풀이방식을 적용할 수 있다.

<br>

### Python

#### 첫번째 풀이

재귀로 풀이했다. n 의 범위가 0부터 30이라 통과할 수 있었다.

반복 연산이 많아서 n 의 범위가 클 경우 시간 초과가 발생할 수 있다.

<br>

#### 두번째 풀이

첫번째 풀이와 달리 계산 결과를 리스트에 저장해두었다가 동일한 계산의 경우 재계산 하지않고 리스트에서 바로 가져온다.

교재에서는 이 풀이를 하향식 풀이로 정의했다. n 을 0, 1까지 재귀 호출로 줄여나간 후 리턴할 값들은 리스트에서 저장하여 동일한 계산시 리스트에서 가져오면서 계산 횟수를 줄인다.

<br>

#### 세번째 풀이

교재에서는 이 풀이를 상향식 풀이로 정의했다. 두번째 풀이와 달리 n 에서 0, 1 로 내려가는게 아니라 0부터 n까지 올라가는 방식이다.

for 문을 한번 돌면 답을 구할 수 있다. 직전 for 문에서 구한 값들이 다음 for 문에서 바로 활용될 수 있다.

<br>

#### 네번째 풀이

x, y 두 변수만 이용해서 풀이할 수 있다. x, y 를 0, 1로 초기화 한 후 for 문을 돌면서 x 에는 y 의 값을 할당하고, y 에는 x + y 의 값을 할당한다. 

n 피보나치 수를 구하기 위해 n번 for 문을 돌면 x 에는 n 피보나치 수가 담긴다.

0과 1은 각각 0, 1의 피보나치 수를 나타낸다. for 문을 돌면서 x 에는 직전 y 의 값이 담기는데 이 y 는 전전의 x, y의 합이다. for 문을 돌면서 x 에는 전전 x, y 의 합이 담기고, y 에는 직전 x, y 의 합이 담기는 것과 같다(정확히는 for 문을 한번 돌았을 경우는 제외하고 두번 돌았을 경우부터 해당한다).

<br>

```
0 1
  1 1
    1 2
      2 3
        3 5
          5 8
```

위는 초기 값부터 시작해서 for 문을 한번씩 돌 때마다 x, y 의 값이 변화하는 모습을 나타낸다. 왼쪽에서 x 값을 나타내는데 이는 0부터 시작하는 피보나치 n의 값의 증가 양상과 동일하다.

for 문을 2번 돌면 피보나치 0, 피보나치 1의 값이 더해진 1이 x에 더해지므로 앞서 얘기했던 전전의 x, y 의 합이 담기는 것과 동일하다.

<br>

### Java

#### FibonacciNumber509

교재에서는 해당 방식을 하향식 풀이라고 한다.

재귀를 활용한다. 동일 연산을 반복하지 않도록 메모이제이션 기법을 사용한다.

n 이 해시맵의 키로 존재하면 값을 바로 리턴하고 키로 존재하지 않으면 값을 구해서 해시맵에 넣어준 뒤 값을 리턴한다. 동일한 n 에 대한 요청이 있으면 다시 재귀호출하지 않고 해시맵의 값을 바로 리턴할 수 있다.

<br>

#### FibonacciNumber509_2

교재에서는 해당 방식을 상향식 풀이라고 한다.

배열을 활용한다. for 문을 돌면서 이전 루프에서 구한 값을 현재 루프의 값을 구하는데 사용한다.

<br>

#### FibonacciNumber509_3

교재의 풀이를 참고했다. 해시맵이나 배열을 사용하지 않고 변수만 사용한다.

x 와 y 를 각각 0과 1로 초기화하고 for 문을 n 번 돈다. for 문을 돌면서 z 에 x 와 y 의 합을 할당하고, x 에는 직전 y 값을 할당하고, y 에는 x 와 y 의 합(z) 를 할당한다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


#  LeetCode

## [179. Largest Number](https://leetcode.com/problems/largest-number/)

### Python

정렬 유형의 문제다.

다만 비교 조건을 단순히 정수의 대소비교로 할 수 없다. 리스트의 숫자들을 조합해서 가장 큰 숫자를 만들어야 한다. 앞자리수가 큰 숫자일수록 리스트의 앞에 와야 한다. 그리고 300, 30 의 경우 30300 이 30030 보다 크기 때문에 30이 300보다 앞에 와야 한다.

이런 대소비교를 어떻게 해야할지 쉽게 떠오르지 않았는데 교재의 풀이를 통해 간단히 비교할 수 있다는 것을 알았다. 대소비교는 두 숫자를 문자열로 만든 뒤 순서를 바꿔서 서로를 합한 값 중 누가 더 큰지를 비교하면 된다. 예를 들어 9, 30 의 경우 930, 309 를 비교해서 어느 값이 더 큰지를 비교한다.

대소비교를 위의 방법으로 진행하면 정렬은 다양하게 구현이 가능하다. 교재에서는 삽입 정렬로 풀이했고, 따로 병합 정렬, 퀵 정렬로 풀이해봤는데 이 정렬들도 모두 가능했다.

<br>

입력 값이 [0, 0] 인 경우 "00" 이 아닌 "0" 을 리턴해야 해서 리스트의 요소들을 문자열로 변환한 뒤 join 으로 묶은 이후 다시 정수로 변환하고 문자열로 변환하는 과정을 거쳤다.

<br>

### Java

교재의 풀이를 참고했다. 대소비교를 어떻게 할지 고민됐는데 교재에서 간단한 방법을 소개했다. 두 숫자를 문자열로 만든 뒤 순서를 바꿔서 서로를 합한 값 중 누가 더 큰지를 비교하면 된다.

교재에서는 대소 비교시 Long.parseLong 을 사용하는데 현재는 Leetcode 의 입력값에 변화가 있었는지 "10000000001000000000" 해당 케이스가 존재하여 Long.parseLong 으로는 통과할 수 없다. Long.parseLong 대신 Double.parseDouble 를 사용하면 통과할 수 있다.

<br>

### Kotlin

#### LargestNumber179

정렬 조건은 python, java 풀이와 동일하게 적용했으나 정렬 함수는 직접 구현하지 않고 내장 함수인 sortedWith 을 사용했다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰
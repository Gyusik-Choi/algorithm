# LeetCode

## [148. Sort List](https://leetcode.com/problems/sort-list/)

### Python

연결 리스트를 정렬해야 한다. 교재의 풀이를 참고해서 병합 정렬을 이용한 방법과 sort 내장 함수를 이용한 방법으로 풀이했다.

<br>

#### 병합 정렬

병합 정렬을 하려면 분할을 해야 하는데, 정렬할 대상이 배열이 아닌 연결 리스트라 인덱스를 사용하기 어렵다. 인덱스 대신 런너 기법을 통해 연결 리스트를 분할했다. 런너 기법은 slow, fast 두 변수를 두고 slow 는 연결 리스트를 한 칸씩, fast 는 연결 리스트를 두 칸씩 이동한다.

여기서는 slow, fast 외에 half 변수를 추가로 둬서 head 와 slow 의 연결을 끊는 역할을 한다. half 는 slow 의 직전 노드를 가리킨다. fast 가 끝까지 이동하면 slow 는 가운데에 있고, half 는 slow 의 이전 노드를 가리킨다. fast 가 끝까지 이동한 후에는 half 의 next 를 None 으로 해서 head 와 slow 의 연결을 끊는다. head 와 slow 를 기준으로 더 이상 분할할 수 없을 때 까지 계속 분할한다. 

분할한 후에는 노드간의 값 비교를 통해 정렬을 하면서 병합한다. 값 비교를 할 때 l1 의 값이 l2 보다 더 크다면 l1 과 l2 를 뒤집는다. 뒤집은 후 l1.next 를 찾기 위해 l1.next 와 l2 로 재귀 호출을 한다. l1.next 를 찾는 재귀 호출을 하기 때문에 노드 간의 연결이 끊기지 않으면서 정렬을 수행할 수 있다.

<br>

#### sort 내장 함수

노드의 값만 리스트에 모아서 정렬한 후 노드를 순회하면서 노드의 값을 정렬된 배열의 값으로 변경한다.

<br>

### Java

#### SortList148

교재의 풀이를 참고했다.

연결리스트를 정렬해야 해서 런너기법을 활용해서 노드를 이동하고 분할정복을 통해 병합정렬로 구현한다.

연결리스트를 반으로 나눌 때 half, slow, fast 3개의 변수를 이용한다. 

half 는 slow 의 직전 노드를 가리키면서 head 와 slow 의 연결을 끊는 역할을 한다. slow 는 한칸씩 이동하면서 연결리스트의 가운데 정점을 가리키는 노드고, fast 는 두칸씩 이동하면서 연결리스트의 끝까지 이동한다.

노드를 병합할 때 l1, l2 변수 중 l1 을 기준으로 병합하기 위해 l1 에 더 작은 값을 갖는 노드가 오도록 한 뒤, l1.next 를 찾기 위해 l1.next 와 l2 를 재귀호출한다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰



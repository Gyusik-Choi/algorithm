# LeetCode

## 617. Merge Two Binary Trees

### Python

어려운 문제였다. 재귀로 풀이할 수 있다.

재귀 호출로 내려가되 새로운 노드를 생성하면서 자식 노드로 내려간다. 맨 아래 자식 노드에서 노드를 리턴하고 부모 노드에서 이 노드를 왼쪽 혹은 오른쪽 자식 노드로 둔다. 부모 노드는 다시 자신의 부모 노드로 자신의 노드를 올려보내고 최종적으로 맨 위 부모 노드에서 노드를 리턴하면서 종료된다.

재귀 호출을 할 때 노드 2개를 모두 인자로 넣는다. 재귀 호출돼서 인자로 들어온 노드 2개가 모두 None 이면 None 을 리턴하고, 노드 1개만 None 이면 None 이 아닌 노드를 리턴한다. 

노드 2개 모두 None 인 경우는 당연히 재귀 호출을 더 할 필요가 없고, 노드 1개만 None 인 경우도 재귀 호출을 더 할 필요가 없다. 어차피 하나의 노드만 존재하기 때문에 이 노드의 자식이 몇 개가 있는지 관계없이 그대로 리턴하면 된다.

<br>

이 문제에서 가장 궁금했던 부분은 두 노드가 주어지는데 하나의 노드를 탐색하면서 다른 노드의 동일한 위치는 어떻게 알 수 있는지였다. 방법은 둘 다 탐색하는 것이다.

둘 다 탐색하면서 둘 다 없으면 None 을 리턴하고, 둘 중 하나가 None 이면 나머지 존재하는 노드를 그대로 리턴하면 된다.

<br>

### Java

어려운 문제였다.

root1, root2 노드의 왼쪽 자식노드, 오른쪽 자식노드를 각각 재귀호출한다. root1, root2 둘 중 하나라도 null 이면 탐색을 더 할필요가 없다. null 이 아닌 노드를 리턴하거나 둘 다 null 이면 null 을 리턴한다.

둘 다 null 이 아니면 root1, root2 의 val 을 합쳐서 새 노드를 만든다. 새 노드의 왼쪽, 오른쪽 자식 노드를 각각 재귀호출한 결과값으로 설정한다. 그리고 이렇게 만들어진 새 노드를 리턴하면서 최종적으로 병합된 노드를 리턴하게 된다.

<br>

<참고>

파이썬 알고리즘 인터뷰

자바 알고리즘 인터뷰


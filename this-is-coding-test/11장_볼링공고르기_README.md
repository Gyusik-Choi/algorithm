# 이것이 코딩테스트다

## 챕터 11 5번 볼링공 고르기

그리디 알고리즘 문제다.

<br>

### 파이썬 1번 풀이

하나의 숫자당 구할 수 있는 조합은 남아 있는 숫자의 갯수 - 1이다.

N이 아니라 남아 있는 숫자라고 한 이유는 예를 들어 1에 대한 조합을 구하고 나면 1을 제외시켜줘야 한다. 1을 제외시키지 않으면 경우의 수가 겹치게 된다. 1, 2, 3, 4, 5가 있는데 1은 1, 2/ 1, 3/ 1, 4/ 1, 5 조합을 구할 수 있고 2를 구할때 2, 1/ 2, 2/ 2, 3/ 2, 4/ 2, 5 이렇게 된다. 1, 2와 2, 1은 같은 경우기 때문에 겹친다. 이를 막기 위해 조합을 구한 수는 빼줘야 한다.

각 숫자별 갯수를 구하고, for 문을 돌면서 N에서 for 문 요소의 갯수를 빼준 다음 N과 for 문 요소의 갯수를 곱해준다.

1, 2, 2, 3, 3은 [1, 2, 2] 갯수를 가지고 [1, 2, 2]의 반복문을 돌면서 N에서 반복문 요소의 값을 빼주고 N에서 요소의 값을 곱해준 총합을 구하면 된다.

N과 요소의 값을 곱해주는 이유는 예를 들어 1 2 2 3 3에서 2는 2개가 있는데 이들의 조합은 각각 3개씩이다. 1번 인덱스의 2도 3개, 2번 인덱스의 2도 3개다. 그래서 N - 2를 해주고 N과 2를 곱해준다.

<br>

### 파이썬 2번 풀이

조합을 활용해서 풀이했다. 조합의 경우를 구하는 배열이 비어있으면 볼링공을 바로 넣고, 볼링공이 있으면 배열에 있는 볼링공 인덱스 보다 현재 볼링공의 인덱스가 더 크면서 볼링공의 번호가 같지 않으면 배열에 넣어준다.

<br>

### 파이썬 3번 풀이

볼링공 무게가 최소 1부터 최대 10까지다. 볼링공 무게별 갯수 정보를 담는 배열 weights 를 11 크기로 만든다.

볼링공 무게는 입력마다 1부터 M까지 존재한다. 1부터 M + 1까지 반복문을 돌면서 1부터 M까지의 볼링공 총 갯수에서 해당 볼링공 무게 갯수를 빼준 다음에 해당 볼링공 무게 갯수만큼 곱한 값을 누적한다.

각 볼링공 무게별로 자신과 동일한 무게의 볼링공을 제외하고 나머지 무게의 볼링공의 갯수만큼 조합을 갖는다. 이때 동일한 볼링공은 각각 나머지 무게와의 볼링공 갯수만큼 조합을 갖게 돼서 해당 볼링공 갯수 * 나머지 볼링공 갯수를 곱해야 한다.

<br>

<참고>

https://techblog-history-younghunjo1.tistory.com/281

https://wooono.tistory.com/543


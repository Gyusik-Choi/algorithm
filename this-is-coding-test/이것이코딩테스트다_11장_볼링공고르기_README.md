# 이것이 코딩테스트다

## 챕터 11 5번 볼링공 고르기

그리디 알고리즘 문제다.

<br>

### 1번 풀이

N개의 숫자에서 2개를 선택하는 횟수는 1부터 N - 1을 모두 더한 값이다.

이를 활용해서 2개를 선택하는 횟수를 구한 후에 겹치는 숫자들끼리 선택하는 횟수를 빼는 방법으로 풀이했다.

겹치는 숫자를 구하는 방법이 비효율적이어서 아쉬웠다.

<br>

### 2번 풀이

1번에서 아쉬웠던 겹치는 숫자를 구하는 방법을 개선했다.

카운팅 정렬에서 쓰는 방법을 활용했다. 1부터 N까지의 숫자를 인덱스로 하는 배열을 만들고 초기 값을 모두 0으로 둔다. 숫자 목록을 for 문으로 돌면서 나오는 숫자에 해당하는 인덱스 배열의 값을 1씩 더했다.

<br>

### 3번 풀이

하나의 숫자당 구할 수 있는 조합은 남아 있는 숫자의 갯수 - 1이다.

N이 아니라 남아 있는 숫자라고 한 이유는 예를 들어 1에 대한 조합을 구하고 나면 1을 제외시켜줘야 한다. 1을 제외시키지 않으면 경우의 수가 겹치게 된다. 1, 2, 3, 4, 5가 있는데 1은 1, 2/ 1, 3/ 1, 4/ 1, 5 조합을 구할 수 있고 2를 구할때 2, 1/ 2, 2/ 2, 3/ 2, 4/ 2, 5 이렇게 된다. 1, 2와 2, 1은 같은 경우기 때문에 겹친다. 이를 막기 위해 조합을 구한 수는 빼줘야 한다.

각 숫자별 갯수를 구하고, for 문을 돌면서 N에서 for 문 요소의 갯수를 빼준 다음 N과 for 문 요소의 갯수를 곱해준다.

1, 2, 2, 3, 3은 [1, 2, 2] 갯수를 가지고 [1, 2, 2]의 반복문을 돌면서 N에서 반복문 요소의 값을 빼주고 N에서 요소의 값을 곱해준 총합을 구하면 된다.

N과 요소의 값을 곱해주는 이유는 예를 들어 1 2 2 3 3에서 2는 2개가 있는데 이들의 조합은 각각 3개씩이다. 1번 인덱스의 2도 3개, 2번 인덱스의 2도 3개다. 그래서 N - 2를 해주고 N과 2를 곱해준다.

<br>

### 4번 풀이

조합을 활용해서 풀이했다. 조합의 경우를 구하는 배열이 비어있으면 볼링공을 바로 넣고, 볼링공이 있으면 배열에 있는 볼링공 인덱스 보다 현재 볼링공의 인덱스가 더 크면서 볼링공의 번호가 같지 않으면 배열에 넣어준다.

<br>

### 5번 풀이

볼링공 무게가 최소 1부터 최대 10까지다. 볼링공 무게별 갯수 정보를 담는 배열 weights 를 11 크기로 만든다.

볼링공 무게는 입력마다 1부터 M까지 존재한다. 1부터 M + 1까지 반복문을 돌면서 1부터 M까지의 볼링공 총 갯수에서 해당 볼링공 무게 갯수를 빼준 다음에 해당 볼링공 무게 갯수만큼 곱한 값을 누적한다.

각 볼링공 무게별로 자신과 동일한 무게의 볼링공을 제외하고 나머지 무게의 볼링공의 갯수만큼 조합을 갖는다. 이때 동일한 볼링공은 각각 나머지 무게와의 볼링공 갯수만큼 조합을 갖게 돼서 해당 볼링공 갯수 * 나머지 볼링공 갯수를 곱해야 한다.

<br>

### Java 1번 풀이

조합을 활용했으나 교재에서 제시하는 카운팅 정렬 기법이 포함된 풀이가 더 효율적이다. 교재에서 제시된 풀이는 O(N) 에 풀이할 수 있다.



<참고>

https://techblog-history-younghunjo1.tistory.com/281

https://wooono.tistory.com/543


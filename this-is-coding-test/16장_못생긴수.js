// 못생긴 수마다 2 3 5 를 각각 곱해줘야 하는데 
// 정렬된 상태를 유지하기 위해
// 못생긴 수 최소값을 찾아서 곧장 2 3 5 를 곱하지 않는다
//
// 1 을 제외하고
// 2 3 5 만을 소인수로 가지려면
// 못생긴 수에서 2 3 5 를 곱해줘야 한다
// 못생긴 수마다 2 3 5 를 순차적으로 곱해나가기 위해
// 2 3 5 가 각자 곱할 인덱스를 관리할 변수
// i2, i3, i5 를 둔다
// dp 배열의 0번 인덱스는 1이고
// 1번 인덱스부터 값을 구해나간다
// 
// 앞서 2 3 5 는 각각 못생긴 수마다 순차적으로 곱해나가야 한다고 했다
// 못생긴 수마다 2 3 5 를 각각 곱해줘야 하는 것은 맞는데
// 정렬된 상태를 유지하면서 dp 배열의 값을 업데이트 하기 위해
// 못생긴 수 최소값을 하나 찾았다고 2 3 5 를 한번에 곱하지 않는다
// 
// next2, next3, next5 중에서 최소값을 찾는다
// 그리고 for loop 상의 인덱스 값에 해당 하는 dp 배열을 최소값으로 업데이트 한다
// 이 최소값과 같은 값을 next2, next3, next5 중에서 찾고
// 이때 같은 값의 경우 next2, next3, next5 에 대응하는 i2, i3, i5 의 값을
// 1 올려준다
// 1 올려주는 의미는 
// 곱해야할 못생긴 수를 이전에 곱한 못생긴 수보다 더 큰 수로 설정해주는 것이다
// 그리고 next2, next3, next5 중 대응하는 수와 곱해준다
//
// 기존 README 의 오류가 있었다 (현재는 수정)
// 2 3 5 의 배수를 구해야 한다고 했으나
// 2 3 5 의 배수 외에도 될 수 있는 숫자들이 있다
// 2 3 5 만을 소인수로 갖기 때문에 배수 외에
// 서로 간에 곱셈이 가능하다
// 못생긴 수 하나마다 2 3 5 를 곱해줘야 하는데
// 이를 오름차순으로 구할 수 있으면
// 정답을 찾을 수 있다

const n = 11;

const dp = new Array(n).fill(0);
dp[0] = 1;

let i2 = 0;
let i3 = 0;
let i5 = 0;

let next2 = 2;
let next3 = 3;
let next5 = 5;

for (let i = 1; i < n; i++) {
  dp[i] = Math.min(next2, next3, next5);

  if (dp[i] === next2) {
    i2 += 1;
    next2 = dp[i2] * 2;
  }

  if (dp[i] === next3) {
    i3 += 1;
    next3 = dp[i3] * 3;
  }

  if (dp[i] === next5) {
    i5 += 1;
    next5 = dp[i5] * 5;
  }
}
console.log(dp);
console.log(dp[n - 1]);

// https://gammistory.tistory.com/38?category=900244

# 이것이 코딩테스트다

## 챕터 11 6번 무지의 먹방 라이브

어려운 문제였다. 프로그래머스 사이트에서 풀이할 수 있는 카카오 코딩테스트 문제다.

가장 먼저 든 방법은 문제에서 제시해준데로 구현하는 것이었으나 이는 시간 초과에 걸리거나, 효율성 채점에서 통과하지 못할 것이라고 생각했다.

먹는데 가장 적은 시간이 필요한 음식부터 제거해야 겠다는 생각이 들었으나 이어지는 의문을 제대로 해결하지 못했다. 

k보다 food_times의 음식 길이가 더 길어서 한 사이클을 돌기도 전에 음식을 다 먹으면 어떻게 처리를 해야할지, food_times 각 원소의 최소 값이 1이 아닐 수 있어서 한 사이클을 돌더라도 한 음식을 다 먹는다는 보장이 없는데 이는 어떻게 해야할지 등의 의문이 있었다.

결국 해설을 참조해서 문제를 풀이할 수 있었다.

가장 적은 시간이 걸리는 음식을 찾는 것은 힙 이용해서 해결할 수 있었다. 힙에 모든 food_times의 원소를 (시간, 인덱스 + 1) 로 넣어준다. 인덱스를 넣는 이유는 문제에서 무지는 순서대로 음식을 먹어나기 때문에 무지가 몇번째 음식을 먹었는지 파악하기 위함이다.

만약에 food_times의 총합보다 k가 크거나 같으면 음식을 다 먹을때까지 방송이 중단될 수 없어서 바로 -1을 리턴한다.

그렇지 않으면 위에서 언급한 힙에 food_times의 원소를 (시간, 인덱스 + 1)로 넣어준다. 음식의 길이를 저장하는 food_length 변수를 두고, 힙에서 원소를 하나 꺼낼때 마다 food_length 값을 1씩 줄여나간다. 

k에서 최소 시간이 소요되는 한 음식을 다 먹는 만큼의 사이클을 돌린 값을 빼줄 것이라 food_length 값을 1씩 줄여나갈 수 있다. 이러면 예를 들어 5개의 음식이 1 이상이었다면 1개의 음식이 줄어서 4개의 음식만 남게 된다. 그래서 몇개 음식이 남았는지 알기 위해 food_length 변수를 둔다.

previous_time 변수는 이전에 먹은 음식의 시간을 알기 위해 둔다. k에서 최소 시간이 소요되는 한 음식을 다 먹는 만큼의 사이클 돌린 값을 뺀다고 했는데 이때 시간은 앞선 시간이 고려되지 않은 한 음식 자체를 다 먹는 시간이다. 앞선 사이클에 의해 힙에서 꺼낸 음식의 시간도 줄어야하기 때문에 이를 위해 previous_time 변수를 두고 k에서 빼줄때 현재 시간에서 previous_time을 빼준 값에 food_length를 곱해준다. previous_time은 처음에는 0으로 두고 힙에서 꺼낼때마다 현재 시간을 넣어준다. 그러면 다음 힙에서 꺼낸 값에서 previous_time을 빼는데 활용할 수 있다.

힙에서 꺼내는 조건으로 while문을 쓰는데 while문의 조건은 k가 (현재 최소 음식의 시간 - previous_time)에서 food_length를 곱한 값이 0보다 클때 까지다. 이는 한 음식을 다 먹는 시간을 k에 뺐을때 0보다 클 경우를 만족한다는 의미다. 즉 한 음식을 다 먹는 사이클을 돌릴 수 있다는 뜻이다.

만약에 0보다 작다면 한 음식을 다 먹는 사이클을 돌릴 수 없다. 한 음식을 다 먹기 전에 방송이 중단될 것이라는 의미다. 음식을 다 먹는데 필요한 시간 순서가 아니라 처음에 입력받은 인덱스 순서대로 음식을 먹어나가기 위해 인덱스를 기준으로 남은 힙의 요소들을 배열로 재정렬 한다.

k에서 food_length를 나눈 나머지가 재정렬한 배열의 인덱스가 되고 이 인덱스의 첫번째 값은 음식의 시간이고 두번째 값이 인덱스라 두번째 값을 리턴한다. k에서 food_length를 나눈 나머지를 구하는 이유는 k가 food_length보다 크거나 같을 수 있어서다. k가 food_length와 같으면 배열의 인덱스를 하나 초과하게 된다. k가 food_length보다 크면 한 음식을 순서대로 다 먹을 수 있다는 의미라 몇번이나 순서대로 음식을 다 먹는 것과 관계없이 답을 구하기 위해 k에서 food_length를 나눈 나머지 값을 구한다.


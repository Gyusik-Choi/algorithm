# 백준

## 1912

### B_1912.py, B_1912.js, B_1912_2.js

동적계획법은 이전 값을 활용해서 계산 횟수를 줄이는 장점이 있다.

이전 값이라는게 단순히 바로 이전이 아니라 현재보다 이전의 값이 누적되온 총합이다.

이 점을 조금더 생각했다면 해결 방법에 조금 더 근접할 수 있었을듯 한데 아쉽게도 다른 분들의 코드를 보고 파악할 수 있었다.

<br>

1 4 -3 2

이 상황에서 최대값은 5다.

1 4 -2 3

이 상황에서 최대값은 6이다.

<br>

위의 경우는 1, 4에서 -3을 빼지 않아야 더 큰 값이 나오고, 아래의 경우는 -2를 빼고 3까지 더해야 더 큰 값이 나온다.

위의 경우를 작성한 코드를 바탕으로 보면 1, 5, 2, 4가 된다. 1은 그대로 1로 시작하고 4를 만나면 1과 4를 더하는 것과 4 중에서 더 큰 값을 선택한다. 전자가 더 커서 5가 된다. 5에서 -3을 뺀 값과 -3 중에서 더 큰 값은 전자라서 2가 된다. 2와 2를 더한 값과 2 중에서도 전자가 더 크므로 4가 된다.

아래의 경우는 1, 5, 3, 6이 된다. 1은 그대로 1로 시작하고 1과 4를 더한 값이 4보다 더 작기에 5가 된다. 그 다음은 5와 -2를 더한 값이 -2 보다 크므로 3이 된다. 3과 3을 더한 값은 3보다 더 크므로 6이 된다.

예시를 조금 더 추가해보면

-1 -2 3

이런 경우가 있다고 하면 -1, -1, 3이 된다.

마지막 숫자인 3을 보면 이전까지 누적합의 최대는 -1이다. -1에서 3을 더하는 것 보다는 이전까지의 값을 버리고 3을 택하는게 더 크다.

즉 이전 까지의 값과 현재 값을 더한 것 보다 현재 값이 더 크면 이전까지의 값을 버리고 새롭게 시작할수 있다.

<br>

이 부분을 제대로 생각하지 못했다. n ^ 2 풀이 방식을 사용했을때 정답은 찾는듯 했으나 역시나 시간 초과로 백준 사이트에서는 통과할 수 없었다. n ^ 2 풀이 방식을 썼던 이유는 어느 지점이 최대 값을 찾게 되는 시작점인지를 알 수 없어서 n개의 숫자가 있다고 하면 0번 인덱스부터 n - 1(끝)까지, 1번 인덱스부터 n - 1까지, 2번 인덱스부터 n - 1까지... 이런 식으로 모든 시작점을 검사하려했다.

<br>

### B_1912_2.py

동적 계획법(다이나믹 프로그래밍) 유형의 문제다.

직전 누적합을 보면서 현재 숫자와 더했을 때 현재 숫자보다 커진다면 더하고 현재 숫자보다 작아진다면 현재 숫자를 유지한다(<u>직전 누적합이 음수면 더하지 않는 것과 동일하다</u>).

현재 숫자를 유지하게 되면 그 지점부터는 기존 누적합은 버리고 새롭게 현재 숫자부터 더하기 시작하게 된다.

<br>

### B_1912_3.py

'파이썬 알고리즘 인터뷰' 교재에 나온 [이 문제](https://leetcode.com/problems/maximum-subarray/description/) 의 풀이를 참고했다. 교재에서는 위의 B_1912_2.py 에 언급한 직전 누적합이 음수면 더하지 않는 방식을 사용한다.

이 풀이는 별도의 dp 배열을 사용하지 않아서 기존 풀이보다 공간 복잡도를 줄일 수 있었다. 입력받은 리스트에 직접 더해나가는 방식을 사용한다.

<br>

<참고>

https://sihyungyou.github.io/baekjoon-1912

https://mygumi.tistory.com/97

파이썬 알고리즘 인터뷰


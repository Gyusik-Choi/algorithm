# 백준

## 2580

### 시간초과 코드

시간초과 코드의 경우,

0으로 되어있는 원소의 인덱스 위치만 따로 배열에 모았다.

0인 위치에 올 수 있는 후보 숫자는 1~9 중에 하나다. 그래서 1부터 9까지 반복문을 돌면서 하나씩 가로 검사, 세로 검사, 3 x 3 크기의 검사를 수행해서 이 숫자가 0에 들어올 수 있는 숫자인지 체크했다.

일단 이 검사를 통과하면 다음 0 위치의 후보를 찾아나섰다. '일단'이라고 표현한 이유는 추후의 다른 0 위치의 검사들을 수행하면서 아까 후보 숫자가 틀렸을 가능성이 있기 때문이다. 그래서 틀리면 그 다음 후보 숫자로 다시 검사를 수행할 수 있도록 재귀를 요청하는 코드 아래에 다시 0의 위치의 숫자를 기존의 후보 숫자가 아닌 0으로 만드는 코드를 넣었다.

재귀가 올라갈 때마다 카운트를 1씩 올려서 0 원소의 인덱스 위치만 모은 배열의 길이만큼 카운트가 올라가면 전체 스도구 배열을 출력한다.

이 방식을 python, pypy3, java로 수행했으나 모두 시간초과가 났다.

검사에 들어가는 리소스가 크기 때문에 시간초과가 발생한 듯 하다. 옳지 않은 후보로 판명나면 추후에 가로, 세로, 3x3을 모두 다시 검사해서 후보를 찾아야 한다. 이때 후보가 될 가능성이 없는 후보도 검사에 들어간다.

만약에 미리 후보가 될 가능성이 있는 후보를 다 찾아놓고 그 후보들 안에서만 검사를 수행하면 리소스를 줄일 수 있다.

(node.js 로는 통과했다)

<br>

### 통과 코드

그래서 방법을 조금 바꾸어서,

1부터 9까지 하나씩 넣어보면서 되는지 안되는지 알아보는게 아니라 아예 1부터 9중에 어떤 숫자가 될 수 있는지 미리 간추려냈다. 즉 이전 방식은 1부터 9까지 1부터 검사를 돌다가 아니면 다시 2부터 검사 시작하고 아니면 ... 이렇게 가능한 숫자가 나올 때 까지 검사를 수행한다.

바꾼 방식은 검사 전체를 돌아서 1~9 중에 어떤 숫자가 가능한지 찾는다. 전체를 돌지만 대신 한번만 수행한다.

그래서 이후 옳지 않다고 판명나도 어떤 숫자가 가능한지 다 찾는게 아니라 가능한 숫자 안에서만 검사를 수행해서 검사의 리소스를 줄일 수 있다.

<br>

### 통과 코드2 (2021. 7. 28 node.js)

약 3달만에 다시 풀게 되었는데 쉽지 않았다. 1 ~ 9를 모두 하나씩 가로, 세로, 사각형 체크를 하지 않고 미리 가능한 숫자들을 추려서 진행했다. 다만 여기서 이해하기 어려웠던 부분은 가능한 숫자들을 이미 찾았기 때문에 이 숫자로 가로, 세로, 사각형 체크를 다시 안해도 된다는 것이었다.

첫 풀이(B_2580_3.js)에서는 스도쿠에 들어갈 수 있는 숫자들을 백트래킹 하기 전에 미리 찾고서 그 숫자들을 반복문을 돌리고 백트래킹을 실행할때 해당 숫자가 들어갔을때 가로, 세로, 사각형에서 겹치는 숫자가 없는지 다시 검사했다. 

그렇지만 가능한 숫자를 찾아놓은 상황이고 다음번 스도쿠 칸에서 그 상황에 맞춰 다시 해당칸에 들어갈 수 있는 숫자들을 다시 찾기 때문에 또 검사할 필요가 없었다. 그리고 이 문제는 여러가지의 가능한 경우의 수가 있더라도 하나만 출력하면 돼서 반복문을 돌려서 백트래킹을 실행한다고 해도 반복문의 나머지 요소들을 모두 돌리지 않고 우선 한번만 스도쿠의 빈칸들을 올바르게 채우면 된다.

<br>

### 특이점

이 문제에서 출력을 다 하고서 출력의 종료를 따로 수행하지 않으면 오답이 나온다. 재귀를 돌다가 남은 반복문들이 실행되면서 추가적으로 출력이 발생해서 그런 듯 하다.
# 백준

## 6497

최소 신장 트리 유형의 문제다. 

프림 알고리즘, 크루스칼 알고리즘 등을 활용해서 최소 신장 트리 문제를 해결할 수 있는데 이 풀이에서는 프림 알고리즘을 사용했다.

임의의 집(이 풀이에서는 0번)을 출발점으로 잡고 모든 집들을 연결하되 사이클이 생기지 않도록 해야 한다.

각 집마다 최소 거리를 구하는 리스트 mst 를 float('inf') 로 초기화하고 임의의 출발점으로 정한 0번 값만 0으로 바꾼다. mst 는 거리 값이기 때문에 정점이 아닌 간선의 길이다. 따라서 출발점은 0이고 나머지는 모두 특정 정점에서 해당 정점으로의 최소값이 된다. 

리스트 mst 만으로는 특정 정점이 어딘지는 알 수 없으나 mst 의 값 자체가 집 간을 연결하는 간선 개념의 값임을 인지해야 한다.

최소 비용으로 모든 집들을 연결해야 하기 때문에 최소 거리 값을 갖는 정점을 찾아야 하고 이를 위해 힙을 사용한다. 파이썬에서 힙은 heapq 모듈을 통해 편리하게 사용할 수 있다.

힙 정렬을 할 리스트 heap 에 출발점으로 삼은 0번의 값과 0을 넣는다.

```python
import heapq


heap = []
# 거리, 집 번호
heapq.heappush(heap, (0, 0))
```

<br>

힙에서 꺼내는 값은 최소 거리를 갖는 정점이 된다. 이 값의 총합이 모든 집을 최소 비용으로 연결하는 값이다.

해당 정점과 연결된 정점들을 보면서 mst 의 값과 비교해서 더 작은 거리를 갖으면서 heap 에서 꺼낸적이 없는 정점의 경우 mst 값을 갱신하고 heap 에 넣어준다.

<br>

이번 문제는 입력에 주의해야 한다. 여러 테스트 케이스가 한번에 주어지며 m 과 n 이 모두 0일 경우 종료해야 한다. while 문을 돌면서 입력을 받되 m 과 n 이 모두 0인 경우 while 문을 종료한다.

<br>

<참고>

https://www.acmicpc.net/board/view/54358


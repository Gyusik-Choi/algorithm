# 백준

## 1920

이진 탐색을 활용한 문제다. 선형으로 탐색한다면 O(N)의 시간복잡도를 가지나, 이분 탐색을 통해서 한번에 절반씩 탐색 범위를 줄여나가기 때문에 O(logN)으로 탐색이 가능하다.

이 문제에서는 크기를 바탕으로 탐색을 하기 때문에 정렬을 하고서 탐색을 해야해서 정렬을 수행하기 위한 추가적인 리소스가 필요하지만  이진 탐색은 탐색의 속도를 선형 탐색보다 훨씬 줄여주기 때문에 탐색에 있어서 많은 시간을 줄일 수 있다.

<br>

재귀를 활용해서 탐색을 수행했다. 탐색할 배열의 시작 인덱스, 끝 인덱스, 대상 숫자를 함수의 인자로 넣었다. 만약에 시작 인덱스가 끝 인덱스 보다 크다면 탐색 범위를 벗어났기에 해당하는 숫자가 배열에 없다는 의미다.

시작 인덱스가 끝 인덱스 보다 작거나 같다면 아직 탐색 범위 내에 있다는 것이다. 그래서 시작 인덱스과 끝 인덱스의 합을 나눈 값으로 중앙 인덱스 값을 찾았다. 

이를 바탕으로 중앙 값보다 찾고자 하는 숫자가 작다면 중앙 값보다 왼쪽에 찾을 숫자가 있다는 것이고, 만약에 중앙 값보다 찾고자 하는 숫자가 크다면 중앙 값보다 오른쪽에 찾을 숫자가 있다는 것이다.

```python
def binary_search(start, end, n):
    # 만약에 시작 인덱스가 끝 인덱스 보다 크다면
    if start > end:
        return 0
    
    # 중앙 인덱스
    mid = (start + end) // 2
    # 만약에 대상 숫자 n이 중앙 값이라면 찾은 것
    if arr[mid] == n:
        return 1
    # n이 중앙 값보다 작다면 중앙 값보다 왼쪽에 위치한다
    elif arr[mid] > n:
        return binary_search(start, mid - 1, n)
   	else:
        return binary_search(mid + 1, end, n)


arr = [1, 2, 3, 4, 5]
num = 1
ans = binary_search(0, len(arr) - 1, num)
```

<br>

참고

이것이 코딩테스트다(나동빈)
# 백준

## 12865

DP로 유명한 Knapsack 문제다. 이전부터 정리를 해보고 싶었던 문제인데 제대로 이해하지 못해서 그간 정리를 하지 못했다. 이제 조금은 정리를 해볼 수 있겠다고 느껴서 정리를 해보려 한다.

제한된 무게 안에서 최대의 가치를 찾아야하는 문제다. 물품의 개수와 최대 무게만큼 이차원 dp 배열을 설정한다. 물품 하나마다(i) 제한된 무게를 1부터 최대 무게까지 올리면서(j) 둘을 비교한다. 여기서 i는 입력받은 i - 1번째의 물품을 나타낸다. 즉 i가 3이라고 하면 물품을 3개 넣을 수 있다는 의미가 아니라 입력받은 3번째 물품을 의미한다. 그래서 이 3번째 물품의 무게와 제한된 무게를 1부터 최대 무게까지 비교하면서 배낭에 들어갈 수 있는지, 들어갈 수 있다면 기존의 최대 가치보다 더 높은 가치로 들어갈 수 있는지 확인해야 한다. 

i의 무게 보다 j가 무겁거나 같을때는 i는 배낭에 들어갈 수 있다. 이때 i가 2이상이면 이미 배낭에 다른 물품이 들어있을 수 있다. 그래서 바로 이전에 같은 j무게에서 들어간 물품의 가치가 더 높으면 그 가치를 그대로 택하고(i를 배낭에 넣지 않고 이전에 들어있던 물품을 그대로 유지) 혹은 j에서 i의 무게를 뺀 이전의 가치와 i의 가치 합이 더 크면(이전에 들어있는 물품을 유지하면서 i도 배낭에 새로 넣음) 이것을 택한다.

아마 여기서 의문이 들 수 있는 것은 그러면 1번째와 3번째가 최대 조합일 수 있는데 3번째는 2번째랑만 비교하면 1번째 물품을 볼 수 없는게 아닌가다. DP를 사용하기 때문에 2번째의 값 자체는 이미 1번째와 비교해서 2번째까지에서의 최대 가치를 갖고 있게 된다. 그래서 3번째에서 2번째와 비교를 해도 1번째도 자연스럽게 고려할 수 있게 된 것이다.

<br>

dp배열을 구할때 건을 하나 더 담을지 아니면 안 담을지를 비교하므로 기존 무게가 1만큼 더 가벼운 경우를 고려하는 dp[i - 1] [ j ] 는 불필요한 비교 조건이다. 자세한 내용은 B_12865_2.js 파일에 정리해두었다.

<br>

<참고>

https://gsmesie692.tistory.com/113

https://st-lab.tistory.com/141

파이썬 알고리즘 인터뷰


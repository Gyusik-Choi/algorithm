# 백준

## 1439

### B_1439.py

이것이 코딩테스트다 11장 3번에 수록된 문제이며 그리디 알고리즘을 활용한다.

0과 1로만 이루어진 숫자에서 연속된 숫자를 최소 횟수로 뒤집어서 모두 같은 숫자로 만들어야 한다.

<br>

입력 받은 숫자의 첫 숫자를 나머지 숫자들과 비교해나갔다. 앞 인덱스 숫자가 첫 숫자와 같으면서 현재 인덱스 숫자는 첫 숫자와 다른 경우 뒤집는 횟수를 1 더해줬다.

즉, 0001100 숫자가 주어졌다고 하면 첫 숫자는 0이고 두번째 숫자(인덱스로 1)부터 반복문을 맨 마지막 숫자까지 순회한다. 4번째 숫자(인덱스로 3)는 첫 숫자와 다르면서 자신의 앞의 숫자(3번째 숫자, 인덱스로 2)는 0이라서 첫 숫자와 같다. 이때 횟수를 더해준다.

총 뒤집는 횟수는 0과 1 중에 무엇을 뒤집더라도 최대 차이는 1이다. 예를 들어 10001 이라는 숫자를 보면 1일 경우 뒤집으면 총 2회이고 0일 경우 뒤집으면 총 1회다. 10000 이라는 숫자는 1일 경우 뒤집으면 총 1회이고 0일 경우 뒤집으면 총 1회다.

즉, 어떤 숫자가 주어지더라도 0과 1의 총 뒤집는 횟수는 같거나 차이가 1이다.

이를 통해 추가로 알 수 있는 것은 시작 숫자와 다른 숫자를 뒤집으면 항상 최소 뒤집는 횟수를 만족한다. 10001, 10000 에서 시작 숫자인 1을 기준으로 뒤집으면 각각 2, 1회다. 0을 기준으로 뒤집었다면 각각 1, 1회다. 마지막 숫자(길이가 2 이상일때)가 시작 숫자와 같은 숫자가 주어졌을때 시작 숫자와 같은 숫자를 뒤집을 횟수는 시작 숫자와 다른 숫자를 뒤집을 경우보다 1회 더 뒤집어야 한다.

그래서 시작 숫자와 다른 숫자를 뒤집어서 답을 구했다.

<br>

### B_1439_2.py

0과 1의 연속된 숫자가 몇 개인지 구한 뒤에 더 작은 값을 출력했다. 0과 1의 연속된 숫자 중에서 더 작은 숫자 횟수만큼 뒤집으면 모두 같은 숫자로 만들 수 있다.

<br>

### B_1439_3.py

enumerate 를 사용하려면 range 와 달리 시작 인덱스를 지정할 수 없고 첫번째부터 돌아야 한다. 그래서 prev 변수를 -1 로 세팅하여 첫번째 원소가 0이나 1에 관계 없이 prev 와 다르기 때문에 첫번째 원소의 갯수를 세고 시작할 수 있다.

prev 를 첫번째 원소 값으로 바꿔주고 첫번째 원소가 0이면 cnt_zero 를 1 더하고 1 이면 cnt_one 을 1 더한다. 그 다음 원소도 마찬가지로 prev 와 비교해서 같으면 continue 로 넘어가고 다른 경우 0인지 1인지 비교하여 prev 값을 교체하고 cnt_zero 나 cnt_one 을 더해준다.

for loop 를 마치고 cnt_zero, cnt_one 중 작은 값을 출력한다.